{"version":3,"file":"vega-parser.min.js","sources":["../src/parsers/autosize.js","../src/parsers/padding.js","../src/parsers/encode/util.js","../src/parsers/marks/roles.js","../src/parsers/encode/defaults.js","../src/parsers/encode/entry.js","../src/parsers/encode.js","../src/parsers/encode/rule.js","../src/parsers/signal.js","../src/util.js","../src/parsers/stream.js","../src/parsers/update.js","../src/parsers/signal-updates.js","../src/transforms.js","../src/parsers/scale.js","../src/parsers/projection.js","../src/parsers/guides/constants.js","../src/parsers/marks/marktypes.js","../src/parsers/guides/guide-group.js","../src/parsers/guides/guide-util.js","../src/parsers/guides/guide-mark.js","../src/parsers/guides/legend-gradient.js","../src/parsers/guides/legend-gradient-discrete.js","../src/parsers/guides/legend-gradient-labels.js","../src/parsers/guides/legend-symbol-groups.js","../src/parsers/guides/legend-title.js","../src/parsers/marks/clip.js","../src/parsers/marks/role.js","../src/parsers/marks/definition.js","../src/parsers/marks/interactive.js","../src/parsers/transform.js","../src/parsers/marks/data.js","../src/DataScope.js","../src/parsers/trigger.js","../src/parsers/mark.js","../src/parsers/marks/facet.js","../src/parsers/marks/subflow.js","../src/parsers/legend.js","../src/parsers/title.js","../src/parsers/data.js","../src/parsers/guides/axis-util.js","../src/parsers/guides/axis-config.js","../src/parsers/guides/axis-domain.js","../src/parsers/guides/axis-grid.js","../src/parsers/guides/axis-labels.js","../src/parsers/guides/axis-title.js","../src/parsers/axis.js","../src/parsers/guides/axis-ticks.js","../src/parsers/scope.js","../src/parsers/view.js","../src/Scope.js","../src/config.js","../src/parse.js"],"sourcesContent":["import {isObject} from 'vega-util';\n\nexport default function(spec) {\n  return isObject(spec) ? spec : {type: spec || 'pad'};\n}\n","import {isObject} from 'vega-util';\n\nconst number = _ => +_ || 0;\n\nconst paddingObject = _ => ({top: _, bottom: _, left: _, right: _});\n\nexport default function(spec) {\n  return !isObject(spec) ? paddingObject(number(spec))\n    : spec.signal ? spec\n    : {\n        top:    number(spec.top),\n        bottom: number(spec.bottom),\n        left:   number(spec.left),\n        right:  number(spec.right)\n      };\n}\n","import {extend, hasOwnProperty, isArray, isObject} from 'vega-util';\n\nexport const encoder = _ => isObject(_) && !isArray(_)\n  ? extend({}, _)\n  : {value: _};\n\nexport function addEncode(object, name, value, set) {\n  if (value != null) {\n    const isEncoder = (\n      (isObject(value) && !isArray(value)) ||\n      (isArray(value) && value.length && isObject(value[0]))\n    );\n\n    // Always assign signal to update, even if the signal is from the enter block\n    if (isEncoder) {\n      object.update[name] = value;\n    } else {\n      object[set || 'enter'][name] = {value: value};\n    }\n    return 1;\n  } else {\n    return 0;\n  }\n}\n\nexport function addEncoders(object, enter, update) {\n  for (const name in enter) {\n    addEncode(object, name, enter[name]);\n  }\n  for (const name in update) {\n    addEncode(object, name, update[name], 'update');\n  }\n}\n\nexport function extendEncode(encode, extra, skip) {\n  for (const name in extra) {\n    if (skip && hasOwnProperty(skip, name)) continue;\n    encode[name] = extend(encode[name] || {}, extra[name]);\n  }\n  return encode;\n}\n\nexport function has(key, encode) {\n  return encode && (\n    (encode.enter && encode.enter[key]) ||\n    (encode.update && encode.update[key])\n  );\n}\n","export const MarkRole = 'mark';\nexport const FrameRole = 'frame';\nexport const ScopeRole = 'scope';\n\nexport const AxisRole = 'axis';\nexport const AxisDomainRole = 'axis-domain';\nexport const AxisGridRole = 'axis-grid';\nexport const AxisLabelRole = 'axis-label';\nexport const AxisTickRole = 'axis-tick';\nexport const AxisTitleRole = 'axis-title';\n\nexport const LegendRole = 'legend';\nexport const LegendBandRole = 'legend-band';\nexport const LegendEntryRole = 'legend-entry';\nexport const LegendGradientRole = 'legend-gradient';\nexport const LegendLabelRole = 'legend-label';\nexport const LegendSymbolRole = 'legend-symbol';\nexport const LegendTitleRole = 'legend-title';\n\nexport const TitleRole = 'title';\nexport const TitleTextRole = 'title-text';\nexport const TitleSubtitleRole = 'title-subtitle';\n","import {has} from './util';\nimport {FrameRole, MarkRole} from '../marks/roles';\nimport {array, extend} from 'vega-util';\n\nexport default function(encode, type, role, style, config) {\n  const defaults = {}, enter = {};\n  let update, key, skip, props;\n\n  // if text mark, apply global lineBreak settings (#2370)\n  key = 'lineBreak';\n  if (type === 'text' && config[key] != null && !has(key, encode)) {\n    applyDefault(defaults, key, config[key]);\n  }\n\n  // ignore legend and axis roles\n  if (role == 'legend' || String(role).startsWith('axis')) {\n    role = null;\n  }\n\n  // resolve mark config\n  props = role === FrameRole ? config.group\n    : (role === MarkRole) ? extend({}, config.mark, config[type])\n    : null;\n\n  for (key in props) {\n    // do not apply defaults if relevant fields are defined\n    skip = has(key, encode)\n      || (key === 'fill' || key === 'stroke')\n      && (has('fill', encode) || has('stroke', encode));\n\n    if (!skip) applyDefault(defaults, key, props[key]);\n  }\n\n  // resolve styles, apply with increasing precedence\n  array(style).forEach(name => {\n    const props = config.style && config.style[name];\n    for (const key in props) {\n      if (!has(key, encode)) {\n        applyDefault(defaults, key, props[key]);\n      }\n    }\n  });\n\n  encode = extend({}, encode); // defensive copy\n  for (key in defaults) {\n    props = defaults[key];\n    if (props.signal) {\n      (update = update || {})[key] = props;\n    } else {\n      enter[key] = props;\n    }\n  }\n\n  encode.enter = extend(enter, encode.enter);\n  if (update) encode.update = extend(update, encode.update);\n\n  return encode;\n}\n\nfunction applyDefault(defaults, key, value) {\n  defaults[key] = value && value.signal\n    ? {signal: value.signal}\n    : {value: value};\n}\n","import {error, isObject, isString, peek, splitAccessPath, stringValue} from 'vega-util';\n\nconst scaleRef = scale => isString(scale) ? stringValue(scale)\n  : scale.signal ? `(${scale.signal})`\n  : field(scale);\n\nexport default function entry(enc) {\n  if (enc.gradient != null) {\n    return gradient(enc);\n  }\n\n  let value = enc.signal ? `(${enc.signal})`\n    : enc.color ? color(enc.color)\n    : enc.field != null ? field(enc.field)\n    : enc.value !== undefined ? stringValue(enc.value)\n    : undefined;\n\n  if (enc.scale != null) {\n    value = scale(enc, value);\n  }\n\n  if (value === undefined) {\n    value = null;\n  }\n\n  if (enc.exponent != null) {\n    value = `pow(${value},${property(enc.exponent)})`;\n  }\n\n  if (enc.mult != null) {\n    value += `*${property(enc.mult)}`;\n  }\n\n  if (enc.offset != null) {\n    value += `+${property(enc.offset)}`;\n  }\n\n  if (enc.round) {\n    value = `round(${value})`;\n  }\n\n  return value;\n}\n\nconst _color = (type, x, y, z) =>\n  `(${type}(${[x, y, z].map(entry).join(',')})+'')`;\n\nfunction color(enc) {\n  return (enc.c) ? _color('hcl', enc.h, enc.c, enc.l)\n    : (enc.h || enc.s) ? _color('hsl', enc.h, enc.s, enc.l)\n    : (enc.l || enc.a) ? _color('lab', enc.l, enc.a, enc.b)\n    : (enc.r || enc.g || enc.b) ? _color('rgb', enc.r, enc.g, enc.b)\n    : null;\n}\n\nfunction gradient(enc) {\n  // map undefined to null; expression lang does not allow undefined\n  const args = [enc.start, enc.stop, enc.count]\n    .map(_ => _ == null ? null : stringValue(_));\n\n  // trim null inputs from the end\n  while (args.length && peek(args) == null) args.pop();\n\n  args.unshift(scaleRef(enc.gradient));\n  return `gradient(${args.join(',')})`;\n}\n\nfunction property(property) {\n  return isObject(property) ? '(' + entry(property) + ')' : property;\n}\n\nfunction field(ref) {\n  return resolveField(isObject(ref) ? ref : {datum: ref});\n}\n\nfunction resolveField(ref) {\n  let object, level, field;\n\n  if (ref.signal) {\n    object = 'datum';\n    field = ref.signal;\n  } else if (ref.group || ref.parent) {\n    level = Math.max(1, ref.level || 1);\n    object = 'item';\n\n    while (level-- > 0) {\n      object += '.mark.group';\n    }\n\n    if (ref.parent) {\n      field = ref.parent;\n      object += '.datum';\n    } else {\n      field = ref.group;\n    }\n  } else if (ref.datum) {\n    object = 'datum';\n    field = ref.datum;\n  } else {\n    error('Invalid field reference: ' + stringValue(ref));\n  }\n\n  if (!ref.signal) {\n    field = isString(field)\n      ? splitAccessPath(field).map(stringValue).join('][')\n      : resolveField(field);\n  }\n\n  return object + '[' + field + ']';\n}\n\nfunction scale(enc, value) {\n  const scale = scaleRef(enc.scale);\n\n  if (enc.range != null) {\n    // pull value from scale range\n    value = `lerp(_range(${scale}), ${+enc.range})`;\n  } else {\n    // run value through scale and/or pull scale bandwidth\n    if (value !== undefined) value = `_scale(${scale}, ${value})`;\n\n    if (enc.band) {\n      value = (value ? value + '+' : '')\n        + `_bandwidth(${scale})`\n        + (+enc.band === 1 ? '' : '*' + property(enc.band));\n\n      if (enc.extra) {\n        // include logic to handle extraneous elements\n        value = `(datum.extra ? _scale(${scale}, datum.extra.value) : ${value})`;\n      }\n    }\n\n    if (value == null) value = '0';\n  }\n\n  return value;\n}\n","import applyDefaults from './encode/defaults';\nimport entry from './encode/entry';\nimport rule from './encode/rule';\n\nimport {parseExpression} from 'vega-functions';\nimport {extend, isArray} from 'vega-util';\n\nexport default function(encode, type, role, style, scope, params) {\n  const enc = {};\n  params = params || {};\n  params.encoders = {$encode: enc};\n\n  encode = applyDefaults(encode, type, role, style, scope.config);\n  for (const key in encode) {\n    enc[key] = parseBlock(encode[key], type, params, scope);\n  }\n\n  return params;\n}\n\nfunction parseBlock(block, marktype, params, scope) {\n  const channels = {},\n        fields = {};\n\n  for (const name in block) {\n    if (block[name] != null) { // skip any null entries\n      channels[name] = parse(expr(block[name]), scope, params, fields);\n    }\n  }\n\n  return {\n    $expr:   {marktype, channels},\n    $fields: Object.keys(fields),\n    $output: Object.keys(block)\n  };\n}\n\nfunction expr(enc) {\n  return isArray(enc) ? rule(enc) : entry(enc);\n}\n\nfunction parse(code, scope, params, fields) {\n  const expr = parseExpression(code, scope);\n  expr.$fields.forEach(name => fields[name] = 1);\n  extend(params, expr.$params);\n  return expr.$expr;\n}\n","import entry from './entry';\nimport {peek} from 'vega-util';\n\nexport default function(enc) {\n  let code = '';\n\n  enc.forEach(rule => {\n    const value = entry(rule);\n    code += rule.test ? `(${rule.test})?${value}:` : value;\n  });\n\n  // if no else clause, terminate with null (#1366)\n  if (peek(code) === ':') {\n    code += 'null';\n  }\n\n  return code;\n}\n","import {error, stringValue} from 'vega-util';\n\nconst OUTER = 'outer',\n      OUTER_INVALID = ['value', 'update', 'init', 'react', 'bind'];\n\nfunction outerError(prefix, name) {\n  error(prefix + ' for \"outer\" push: ' + stringValue(name));\n}\n\nexport default function(signal, scope) {\n  const name = signal.name;\n\n  if (signal.push === OUTER) {\n    // signal must already be defined, raise error if not\n    if (!scope.signals[name]) outerError('No prior signal definition', name);\n    // signal push must not use properties reserved for standard definition\n    OUTER_INVALID.forEach(prop => {\n      if (signal[prop] !== undefined) outerError('Invalid property ', prop);\n    });\n  } else {\n    // define a new signal in the current scope\n    const op = scope.addSignal(name, signal.value);\n    if (signal.react === false) op.react = false;\n    if (signal.bind) scope.addBinding(name, signal.bind);\n  }\n}\n","import {isObject} from 'vega-util';\n\nexport function Entry(type, value, params, parent) {\n  this.id = -1;\n  this.type = type;\n  this.value = value;\n  this.params = params;\n  if (parent) this.parent = parent;\n}\n\nexport function entry(type, value, params, parent) {\n  return new Entry(type, value, params, parent);\n}\n\nexport function operator(value, params) {\n  return entry('operator', value, params);\n}\n\n// -----\n\nexport function ref(op) {\n  const ref = {$ref: op.id};\n  // if operator not yet registered, cache ref to resolve later\n  if (op.id < 0) (op.refs = op.refs || []).push(ref);\n  return ref;\n}\n\nexport const tupleidRef = {\n  $tupleid: 1,\n  toString: function() { return ':_tupleid_:'; }\n};\n\nexport function fieldRef(field, name) {\n  return name ? {$field: field, $name: name} : {$field: field};\n}\n\nexport const keyFieldRef = fieldRef('key');\n\nexport function compareRef(fields, orders) {\n  return {$compare: fields, $order: orders};\n}\n\nexport function keyRef(fields, flat) {\n  const ref = {$key: fields};\n  if (flat) ref.$flat = true;\n  return ref;\n}\n\n// -----\n\nexport const Ascending  = 'ascending';\n\nexport const Descending = 'descending';\n\nexport function sortKey(sort) {\n  return !isObject(sort) ? ''\n    : (sort.order === Descending ? '-' : '+')\n      + aggrField(sort.op, sort.field);\n}\n\nexport function aggrField(op, field) {\n  return (op && op.signal ? '$' + op.signal : op || '')\n    + (op && field ? '_' : '')\n    + (field && field.signal ? '$' + field.signal : field || '');\n}\n\n// -----\n\nexport const Scope = 'scope';\n\nexport const View = 'view';\n\nexport function isSignal(_) {\n  return _ && _.signal;\n}\n\nexport function isExpr(_) {\n  return _ && _.expr;\n}\n\nexport function hasSignal(_) {\n  if (isSignal(_)) return true;\n  if (isObject(_)) for (const key in _) {\n    if (hasSignal(_[key])) return true;\n  }\n  return false;\n}\n\nexport function value(specValue, defaultValue) {\n  return specValue != null ? specValue : defaultValue;\n}\n\nexport function deref(v) {\n  return v && v.signal || v;\n}\n","import {Scope, View} from '../util';\nimport {parseExpression} from 'vega-functions';\nimport {error, stringValue} from 'vega-util';\n\nconst Timer = 'timer';\n\nexport default function parseStream(stream, scope) {\n  const method = stream.merge ? mergeStream\n    : stream.stream ? nestedStream\n    : stream.type ? eventStream\n    : error('Invalid stream specification: ' + stringValue(stream));\n\n  return method(stream, scope);\n}\n\nfunction eventSource(source) {\n   return source === Scope ? View : (source || View);\n}\n\nfunction mergeStream(stream, scope) {\n  const list = stream.merge.map(s => parseStream(s, scope)),\n        entry = streamParameters({merge: list}, stream, scope);\n  return scope.addStream(entry).id;\n}\n\nfunction nestedStream(stream, scope) {\n  const id = parseStream(stream.stream, scope),\n        entry = streamParameters({stream: id}, stream, scope);\n  return scope.addStream(entry).id;\n}\n\nfunction eventStream(stream, scope) {\n  let id;\n  if (stream.type === Timer) {\n    id = scope.event(Timer, stream.throttle);\n    stream = {between: stream.between, filter: stream.filter};\n  } else {\n    id = scope.event(eventSource(stream.source), stream.type);\n  }\n\n  const entry = streamParameters({stream: id}, stream, scope);\n  return Object.keys(entry).length === 1\n    ? id\n    : scope.addStream(entry).id;\n}\n\nfunction streamParameters(entry, stream, scope) {\n  let param = stream.between;\n\n  if (param) {\n    if (param.length !== 2) {\n      error('Stream \"between\" parameter must have 2 entries: ' + stringValue(stream));\n    }\n    entry.between = [\n      parseStream(param[0], scope),\n      parseStream(param[1], scope)\n    ];\n  }\n\n  param = stream.filter ? [].concat(stream.filter) : [];\n  if (stream.marktype || stream.markname || stream.markrole) {\n    // add filter for mark type, name and/or role\n    param.push(filterMark(stream.marktype, stream.markname, stream.markrole));\n  }\n  if (stream.source === Scope) {\n    // add filter to limit events from sub-scope only\n    param.push('inScope(event.item)');\n  }\n  if (param.length) {\n    entry.filter = parseExpression('(' + param.join(')&&(') + ')', scope).$expr;\n  }\n\n  if ((param = stream.throttle) != null) {\n    entry.throttle = +param;\n  }\n\n  if ((param = stream.debounce) != null) {\n    entry.debounce = +param;\n  }\n\n  if (stream.consume) {\n    entry.consume = true;\n  }\n\n  return entry;\n}\n\nfunction filterMark(type, name, role) {\n  const item = 'event.item';\n  return item\n    + (type && type !== '*' ? '&&' + item + '.mark.marktype===\\'' + type + '\\'' : '')\n    + (role ? '&&' + item + '.mark.role===\\'' + role + '\\'' : '')\n    + (name ? '&&' + item + '.mark.name===\\'' + name + '\\'' : '');\n}\n","import parseStream from './stream';\nimport {Scope, View} from '../util';\nimport {parseSelector} from 'vega-event-selector';\nimport {parseExpression} from 'vega-functions';\nimport {array, error, extend, isString, stringValue} from 'vega-util';\n\n// bypass expression parser for internal operator references\nconst OP_VALUE_EXPR = {\n  code: '_.$value',\n  ast: {type: 'Identifier', value: 'value'}\n};\n\nexport default function(spec, scope, target) {\n  const encode = spec.encode,\n        entry = {target: target};\n\n  let events = spec.events,\n      update = spec.update,\n      sources = [];\n\n  if (!events) {\n    error('Signal update missing events specification.');\n  }\n\n  // interpret as an event selector string\n  if (isString(events)) {\n    events = parseSelector(events, scope.isSubscope() ? Scope : View);\n  }\n\n  // separate event streams from signal updates\n  events = array(events)\n    .filter(s => s.signal || s.scale ? (sources.push(s), 0) : 1);\n\n  // merge internal operator listeners\n  if (sources.length > 1) {\n    sources = [mergeSources(sources)];\n  }\n\n  // merge event streams, include as source\n  if (events.length) {\n    sources.push(events.length > 1 ? {merge: events} : events[0]);\n  }\n\n  if (encode != null) {\n    if (update) error('Signal encode and update are mutually exclusive.');\n    update = 'encode(item(),' + stringValue(encode) + ')';\n  }\n\n  // resolve update value\n  entry.update = isString(update) ? parseExpression(update, scope)\n    : update.expr != null ? parseExpression(update.expr, scope)\n    : update.value != null ? update.value\n    : update.signal != null ? {\n        $expr:   OP_VALUE_EXPR,\n        $params: {$value: scope.signalRef(update.signal)}\n      }\n    : error('Invalid signal update specification.');\n\n  if (spec.force) {\n    entry.options = {force: true};\n  }\n\n  sources.forEach(source =>\n    scope.addUpdate(extend(streamSource(source, scope), entry))\n  );\n}\n\nfunction streamSource(stream, scope) {\n  return {\n    source: stream.signal ? scope.signalRef(stream.signal)\n          : stream.scale ? scope.scaleRef(stream.scale)\n          : parseStream(stream, scope)\n  };\n}\n\nfunction mergeSources(sources) {\n  return {\n    signal: '['\n      + sources.map(s => s.scale ? 'scale(\"' + s.scale + '\")' : s.signal)\n      + ']'\n  };\n}\n","import parseUpdate from './update';\nimport {parseExpression} from 'vega-functions';\nimport {error} from 'vega-util';\n\nexport default function(signal, scope) {\n  const op = scope.getSignal(signal.name);\n  let expr = signal.update;\n\n  if (signal.init) {\n    if (expr) {\n      error('Signals can not include both init and update expressions.');\n    } else {\n      expr = signal.init;\n      op.initonly = true;\n    }\n  }\n\n  if (expr) {\n    expr = parseExpression(expr, scope);\n    op.update = expr.$expr;\n    op.params = expr.$params;\n  }\n\n  if (signal.on) {\n    signal.on.forEach(_ => parseUpdate(_, scope, op.id));\n  }\n}\n","import {entry} from './util';\n\nconst transform = name => (params, value, parent) =>\n  entry(name, value, params || undefined, parent);\n\nexport const Aggregate = transform('aggregate');\nexport const AxisTicks = transform('axisticks');\nexport const Bound = transform('bound');\nexport const Collect = transform('collect');\nexport const Compare = transform('compare');\nexport const DataJoin = transform('datajoin');\nexport const Encode = transform('encode');\nexport const Expression = transform('expression');\nexport const Extent = transform('extent');\nexport const Facet = transform('facet');\nexport const Field = transform('field');\nexport const Key = transform('key');\nexport const LegendEntries = transform('legendentries');\nexport const Load = transform('load');\nexport const Mark = transform('mark');\nexport const MultiExtent = transform('multiextent');\nexport const MultiValues = transform('multivalues');\nexport const Overlap = transform('overlap');\nexport const Params = transform('params');\nexport const PreFacet = transform('prefacet');\nexport const Projection = transform('projection');\nexport const Proxy = transform('proxy');\nexport const Relay = transform('relay');\nexport const Render = transform('render');\nexport const Scale = transform('scale');\nexport const Sieve = transform('sieve');\nexport const SortItems = transform('sortitems');\nexport const ViewLayout = transform('viewlayout');\nexport const Values = transform('values');\n","import {\n  Aggregate, Collect, MultiExtent, MultiValues, Sieve, Values\n} from '../transforms';\nimport {aggrField, keyFieldRef, ref} from '../util';\n\nimport {isDiscrete, isQuantile, isValidScaleType} from 'vega-scale';\nimport {\n  error, extend, hasOwnProperty, isArray, isObject, isString, stringValue\n} from 'vega-util';\n\nlet FIELD_REF_ID = 0;\n\nconst MULTIDOMAIN_SORT_OPS  = {min: 'min', max: 'max', count: 'sum'};\n\nexport function initScale(spec, scope) {\n  const type = spec.type || 'linear';\n\n  if (!isValidScaleType(type)) {\n    error('Unrecognized scale type: ' + stringValue(type));\n  }\n\n  scope.addScale(spec.name, {\n    type,\n    domain: undefined\n  });\n}\n\nexport function parseScale(spec, scope) {\n  const params = scope.getScale(spec.name).params;\n  let key;\n\n  params.domain = parseScaleDomain(spec.domain, spec, scope);\n\n  if (spec.range != null) {\n    params.range = parseScaleRange(spec, scope, params);\n  }\n\n  if (spec.interpolate != null) {\n    parseScaleInterpolate(spec.interpolate, params);\n  }\n\n  if (spec.nice != null) {\n    params.nice = parseScaleNice(spec.nice);\n  }\n\n  if (spec.bins != null) {\n    params.bins = parseScaleBins(spec.bins, scope);\n  }\n\n  for (key in spec) {\n    if (hasOwnProperty(params, key) || key === 'name') continue;\n    params[key] = parseLiteral(spec[key], scope);\n  }\n}\n\nfunction parseLiteral(v, scope) {\n  return !isObject(v) ? v\n    : v.signal ? scope.signalRef(v.signal)\n    : error('Unsupported object: ' + stringValue(v));\n}\n\nfunction parseArray(v, scope) {\n  return v.signal\n    ? scope.signalRef(v.signal)\n    : v.map(v => parseLiteral(v, scope));\n}\n\nfunction dataLookupError(name) {\n  error('Can not find data set: ' + stringValue(name));\n}\n\n// -- SCALE DOMAIN ----\n\nfunction parseScaleDomain(domain, spec, scope) {\n  if (!domain) {\n    if (spec.domainMin != null || spec.domainMax != null) {\n      error('No scale domain defined for domainMin/domainMax to override.');\n    }\n    return; // default domain\n  }\n\n  return domain.signal ? scope.signalRef(domain.signal)\n    : (isArray(domain) ? explicitDomain\n    : domain.fields ? multipleDomain\n    : singularDomain)(domain, spec, scope);\n}\n\nfunction explicitDomain(domain, spec, scope) {\n  return domain.map(v => parseLiteral(v, scope));\n}\n\nfunction singularDomain(domain, spec, scope) {\n  const data = scope.getData(domain.data);\n  if (!data) dataLookupError(domain.data);\n\n  return isDiscrete(spec.type)\n      ? data.valuesRef(scope, domain.field, parseSort(domain.sort, false))\n      : isQuantile(spec.type) ? data.domainRef(scope, domain.field)\n      : data.extentRef(scope, domain.field);\n}\n\nfunction multipleDomain(domain, spec, scope) {\n  const data = domain.data,\n        fields = domain.fields.reduce((dom, d) => {\n          d = isString(d) ? {data: data, field: d}\n            : (isArray(d) || d.signal) ? fieldRef(d, scope)\n            : d;\n          dom.push(d);\n          return dom;\n        }, []);\n\n  return (isDiscrete(spec.type) ? ordinalMultipleDomain\n    : isQuantile(spec.type) ? quantileMultipleDomain\n    : numericMultipleDomain)(domain, scope, fields);\n}\n\nfunction fieldRef(data, scope) {\n  const name = '_:vega:_' + (FIELD_REF_ID++),\n        coll = Collect({});\n\n  if (isArray(data)) {\n    coll.value = {$ingest: data};\n  } else if (data.signal) {\n    const code = 'setdata(' + stringValue(name) + ',' + data.signal + ')';\n    coll.params.input = scope.signalRef(code);\n  }\n  scope.addDataPipeline(name, [coll, Sieve({})]);\n  return {data: name, field: 'data'};\n}\n\nfunction ordinalMultipleDomain(domain, scope, fields) {\n  const sort = parseSort(domain.sort, true);\n  let a, v;\n\n  // get value counts for each domain field\n  const counts = fields.map(f => {\n    const data = scope.getData(f.data);\n    if (!data) dataLookupError(f.data);\n    return data.countsRef(scope, f.field, sort);\n  });\n\n  // aggregate the results from each domain field\n  const p = {groupby: keyFieldRef, pulse: counts};\n  if (sort) {\n    a = sort.op || 'count';\n    v = sort.field ? aggrField(a, sort.field) : 'count';\n    p.ops = [MULTIDOMAIN_SORT_OPS[a]];\n    p.fields = [scope.fieldRef(v)];\n    p.as = [v];\n  }\n  a = scope.add(Aggregate(p));\n\n  // collect aggregate output\n  const c = scope.add(Collect({pulse: ref(a)}));\n\n  // extract values for combined domain\n  v = scope.add(Values({\n    field: keyFieldRef,\n    sort:  scope.sortRef(sort),\n    pulse: ref(c)\n  }));\n\n  return ref(v);\n}\n\nfunction parseSort(sort, multidomain) {\n  if (sort) {\n    if (!sort.field && !sort.op) {\n      if (isObject(sort)) sort.field = 'key';\n      else sort = {field: 'key'};\n    } else if (!sort.field && sort.op !== 'count') {\n      error('No field provided for sort aggregate op: ' + sort.op);\n    } else if (multidomain && sort.field) {\n      if (sort.op && !MULTIDOMAIN_SORT_OPS[sort.op]) {\n        error('Multiple domain scales can not be sorted using ' + sort.op);\n      }\n    }\n  }\n  return sort;\n}\n\nfunction quantileMultipleDomain(domain, scope, fields) {\n  // get value arrays for each domain field\n  const values = fields.map(f => {\n    const data = scope.getData(f.data);\n    if (!data) dataLookupError(f.data);\n    return data.domainRef(scope, f.field);\n  });\n\n  // combine value arrays\n  return ref(scope.add(MultiValues({values: values})));\n}\n\nfunction numericMultipleDomain(domain, scope, fields) {\n  // get extents for each domain field\n  const extents = fields.map(f => {\n    const data = scope.getData(f.data);\n    if (!data) dataLookupError(f.data);\n    return data.extentRef(scope, f.field);\n  });\n\n  // combine extents\n  return ref(scope.add(MultiExtent({extents: extents})));\n}\n\n// -- SCALE BINS -----\n\nfunction parseScaleBins(v, scope) {\n  return v.signal || isArray(v)\n    ? parseArray(v, scope)\n    : scope.objectProperty(v);\n}\n\n// -- SCALE NICE -----\n\nfunction parseScaleNice(nice) {\n  return isObject(nice)\n    ? {\n        interval: parseLiteral(nice.interval),\n        step: parseLiteral(nice.step)\n      }\n    : parseLiteral(nice);\n}\n\n// -- SCALE INTERPOLATION -----\n\nfunction parseScaleInterpolate(interpolate, params) {\n  params.interpolate = parseLiteral(interpolate.type || interpolate);\n  if (interpolate.gamma != null) {\n    params.interpolateGamma = parseLiteral(interpolate.gamma);\n  }\n}\n\n// -- SCALE RANGE -----\n\nfunction parseScaleRange(spec, scope, params) {\n  const config = scope.config.range;\n  let range = spec.range;\n\n  if (range.signal) {\n    return scope.signalRef(range.signal);\n  } else if (isString(range)) {\n    if (config && hasOwnProperty(config, range)) {\n      spec = extend({}, spec, {range: config[range]});\n      return parseScaleRange(spec, scope, params);\n    } else if (range === 'width') {\n      range = [0, {signal: 'width'}];\n    } else if (range === 'height') {\n      range = isDiscrete(spec.type)\n        ? [0, {signal: 'height'}]\n        : [{signal: 'height'}, 0];\n    } else {\n      error('Unrecognized scale range value: ' + stringValue(range));\n    }\n  } else if (range.scheme) {\n    params.scheme = isArray(range.scheme)\n      ? parseArray(range.scheme, scope)\n      : parseLiteral(range.scheme, scope);\n    if (range.extent) params.schemeExtent = parseArray(range.extent, scope);\n    if (range.count) params.schemeCount = parseLiteral(range.count, scope);\n    return;\n  } else if (range.step) {\n    params.rangeStep = parseLiteral(range.step, scope);\n    return;\n  } else if (isDiscrete(spec.type) && !isArray(range)) {\n    return parseScaleDomain(range, spec, scope);\n  } else if (!isArray(range)) {\n    error('Unsupported range type: ' + stringValue(range));\n  }\n\n  return range.map(v => (isArray(v) ? parseArray : parseLiteral)(v, scope));\n}\n","import {error, isArray, isObject, stringValue} from 'vega-util';\n\nexport default function(proj, scope) {\n  const config = scope.config.projection || {},\n        params = {};\n\n  for (const name in proj) {\n    if (name === 'name') continue;\n    params[name] = parseParameter(proj[name], name, scope);\n  }\n\n  // apply projection defaults from config\n  for (const name in config) {\n    if (params[name] == null) {\n      params[name] = parseParameter(config[name], name, scope);\n    }\n  }\n\n  scope.addProjection(proj.name, params);\n}\n\nfunction parseParameter(_, name, scope) {\n  return isArray(_) ? _.map(_ => parseParameter(_, name, scope))\n    : !isObject(_) ? _\n    : _.signal ? scope.signalRef(_.signal)\n    : name === 'fit' ? _\n    : error('Unsupported parameter object: ' + stringValue(_));\n}\n","export const Top = 'top';\nexport const Left = 'left';\nexport const Right = 'right';\nexport const Bottom = 'bottom';\nexport const Center = 'center';\n\nexport const Vertical = 'vertical';\n\nexport const Start = 'start';\nexport const Middle = 'middle';\nexport const End = 'end';\n\nexport const Index  = 'index';\nexport const Label  = 'label';\nexport const Offset = 'offset';\nexport const Perc   = 'perc';\nexport const Perc2  = 'perc2';\nexport const Value  = 'value';\n\nexport const GuideLabelStyle = 'guide-label';\nexport const GuideTitleStyle = 'guide-title';\nexport const GroupTitleStyle = 'group-title';\nexport const GroupSubtitleStyle = 'group-subtitle';\n\nexport const Symbols = 'symbol';\nexport const Gradient = 'gradient';\nexport const Discrete = 'discrete';\n\nexport const Size = 'size';\nexport const Shape = 'shape';\nexport const Fill = 'fill';\nexport const Stroke = 'stroke';\nexport const StrokeWidth = 'strokeWidth';\nexport const StrokeDash = 'strokeDash';\nexport const Opacity = 'opacity';\n\n// Encoding channels supported by legends\n// In priority order of 'canonical' scale\nexport const LegendScales = [\n  Size,\n  Shape,\n  Fill,\n  Stroke,\n  StrokeWidth,\n  StrokeDash,\n  Opacity\n];\n\nexport const Skip = {\n  name: 1,\n  style: 1,\n  interactive: 1\n};\n\nexport const zero = {value: 0};\nexport const one = {value: 1};\n","export const GroupMark = 'group';\nexport const RectMark = 'rect';\nexport const RuleMark = 'rule';\nexport const SymbolMark = 'symbol';\nexport const TextMark = 'text';\n","import {GroupMark} from '../marks/marktypes';\n\nexport default function(mark) {\n  mark.type = GroupMark;\n  mark.interactive = mark.interactive || false;\n  return mark;\n}\n","import {Center, End, Left, Right, Start, Vertical} from './constants';\nimport {value} from '../../util';\nimport {isObject, stringValue} from 'vega-util';\n\nexport function lookup(spec, config) {\n  const _ = (name, dflt) => value(spec[name], value(config[name], dflt));\n\n  _.isVertical = s => Vertical === value(\n    spec.direction,\n    config.direction || (s ? config.symbolDirection : config.gradientDirection)\n  );\n\n  _.gradientLength = () => value(\n    spec.gradientLength,\n    config.gradientLength || config.gradientWidth\n  );\n\n  _.gradientThickness = () => value(\n    spec.gradientThickness,\n    config.gradientThickness || config.gradientHeight\n  );\n\n  _.entryColumns = () => value(\n    spec.columns,\n    value(config.columns, +_.isVertical(true))\n  );\n\n  return _;\n}\n\nexport function getEncoding(name, encode) {\n  const v = encode && (\n    (encode.update && encode.update[name]) ||\n    (encode.enter && encode.enter[name])\n  );\n  return v && v.signal ? v : v ? v.value : null;\n}\n\nexport function getStyle(name, scope, style) {\n  const s = scope.config.style[style];\n  return s && s[name];\n}\n\nexport function anchorExpr(s, e, m) {\n  return `item.anchor === '${Start}' ? ${s} : item.anchor === '${End}' ? ${e} : ${m}`;\n}\n\nexport const alignExpr = anchorExpr(\n  stringValue(Left),\n  stringValue(Right),\n  stringValue(Center)\n);\n\nexport function tickBand(_) {\n  const v = _('tickBand');\n  let offset = _('tickOffset'),\n      band, extra;\n\n  if (!v) {\n    // if no tick band entry, fall back on other properties\n    band = _('bandPosition');\n    extra = _('tickExtra');\n  } else if (v.signal) {\n    // if signal, augment code to interpret values\n    band = {signal: `(${v.signal}) === 'extent' ? 1 : 0.5`};\n    extra = {signal: `(${v.signal}) === 'extent'`};\n    if (!isObject(offset)) {\n      offset = {signal: `(${v.signal}) === 'extent' ? 0 : ${offset}`};\n    }\n  } else if (v === 'extent') {\n    // if constant, simply set values\n    band = 1;\n    extra = true;\n    offset = 0;\n  } else {\n    band = 0.5;\n    extra = false;\n  }\n\n  return {extra, band, offset};\n}\n\nexport function extendOffset(value, offset) {\n  return !offset ? value\n    : !value ? offset\n    : !isObject(value) ? { value, offset }\n    : Object.assign({}, value, { offset: extendOffset(value.offset, offset) });\n}\n","import {Skip} from './constants';\nimport {extendEncode} from '../encode/util';\n\nexport default function(mark, extras) {\n  if (extras) {\n    mark.name = extras.name;\n    mark.style = extras.style || mark.style;\n    mark.interactive = !!extras.interactive;\n    mark.encode = extendEncode(mark.encode, extras, Skip);\n  } else {\n    mark.interactive = false;\n  }\n  return mark;\n}\n","import {one, zero} from './constants';\nimport guideMark from './guide-mark';\nimport {lookup} from './guide-util';\nimport {addEncoders, encoder} from '../encode/util';\nimport {RectMark} from '../marks/marktypes';\nimport {LegendGradientRole} from '../marks/roles';\nimport {extend} from 'vega-util';\n\nexport default function(spec, scale, config, userEncode) {\n  const _ = lookup(spec, config),\n        vertical = _.isVertical(),\n        thickness = _.gradientThickness(),\n        length = _.gradientLength();\n\n  let enter, start, stop, width, height;\n\n  if (vertical) {\n    start = [0, 1];\n    stop = [0, 0];\n    width = thickness;\n    height = length;\n  } else {\n    start = [0, 0];\n    stop = [1, 0];\n    width = length;\n    height = thickness;\n  }\n\n  const encode = {\n    enter: enter = {\n      opacity: zero,\n      x: zero,\n      y: zero,\n      width: encoder(width),\n      height: encoder(height)\n    },\n    update: extend({}, enter, {\n      opacity: one,\n      fill: {gradient: scale, start: start, stop: stop}\n    }),\n    exit: {\n      opacity: zero\n    }\n  };\n\n  addEncoders(encode, {\n    stroke:      _('gradientStrokeColor'),\n    strokeWidth: _('gradientStrokeWidth')\n  }, { // update\n    opacity:     _('gradientOpacity')\n  });\n\n  return guideMark({\n    type: RectMark,\n    role: LegendGradientRole,\n    encode\n  }, userEncode);\n}\n","import {Perc, Perc2, Value, one, zero} from './constants';\nimport guideMark from './guide-mark';\nimport {lookup} from './guide-util';\nimport {addEncoders, encoder} from '../encode/util';\nimport {RectMark} from '../marks/marktypes';\nimport {LegendBandRole} from '../marks/roles';\nimport {extend} from 'vega-util';\n\nexport default function(spec, scale, config, userEncode, dataRef) {\n  const _ = lookup(spec, config),\n        vertical = _.isVertical(),\n        thickness = _.gradientThickness(),\n        length = _.gradientLength();\n\n  let u, v, uu, vv, adjust = '';\n\n  vertical\n    ? (u = 'y', uu = 'y2', v = 'x', vv = 'width', adjust = '1-')\n    : (u = 'x', uu = 'x2', v = 'y', vv = 'height');\n\n  const enter = {\n    opacity: zero,\n    fill: {scale: scale, field: Value}\n  };\n  enter[u]  = {signal: adjust + 'datum.' + Perc, mult: length};\n  enter[v]  = zero;\n  enter[uu] = {signal: adjust + 'datum.' + Perc2, mult: length};\n  enter[vv] = encoder(thickness);\n\n  const encode = {\n    enter: enter,\n    update: extend({}, enter, {opacity: one}),\n    exit: {opacity: zero}\n  };\n\n  addEncoders(encode, {\n    stroke:      _('gradientStrokeColor'),\n    strokeWidth: _('gradientStrokeWidth')\n  }, { // update\n    opacity:     _('gradientOpacity')\n  });\n\n  return guideMark({\n    type: RectMark,\n    role: LegendBandRole,\n    key:  Value,\n    from: dataRef,\n    encode\n  }, userEncode);\n}\n","import {\n  Bottom, Center, GuideLabelStyle, Index, Label, Left, Middle,\n  Perc, Right, Top, Value, one, zero\n} from './constants';\nimport guideMark from './guide-mark';\nimport {lookup} from './guide-util';\nimport {addEncoders, encoder} from '../encode/util';\nimport {TextMark} from '../marks/marktypes';\nimport {LegendLabelRole} from '../marks/roles';\nimport {value} from '../../util';\n\nconst alignExpr = `datum.${Perc}<=0?\"${Left}\":datum.${Perc}>=1?\"${Right}\":\"${Center}\"`,\n      baselineExpr = `datum.${Perc}<=0?\"${Bottom}\":datum.${Perc}>=1?\"${Top}\":\"${Middle}\"`;\n\nexport default function(spec, config, userEncode, dataRef) {\n  const _ = lookup(spec, config),\n        vertical = _.isVertical(),\n        thickness = encoder(_.gradientThickness()),\n        length = _.gradientLength();\n\n  let overlap = _('labelOverlap'),\n      enter, update, u, v, adjust = '';\n\n  const encode = {\n    enter: enter = {\n      opacity: zero\n    },\n    update: update = {\n      opacity: one,\n      text: {field: Label}\n    },\n    exit: {\n      opacity: zero\n    }\n  };\n\n  addEncoders(encode, {\n    fill:        _('labelColor'),\n    fillOpacity: _('labelOpacity'),\n    font:        _('labelFont'),\n    fontSize:    _('labelFontSize'),\n    fontStyle:   _('labelFontStyle'),\n    fontWeight:  _('labelFontWeight'),\n    limit:       value(spec.labelLimit, config.gradientLabelLimit)\n  });\n\n  if (vertical) {\n    enter.align = {value: 'left'};\n    enter.baseline = update.baseline = {signal: baselineExpr};\n    u = 'y'; v = 'x'; adjust = '1-';\n  } else {\n    enter.align = update.align = {signal: alignExpr};\n    enter.baseline = {value: 'top'};\n    u = 'x'; v = 'y';\n  }\n\n  enter[u] = update[u] = {signal: adjust + 'datum.' + Perc, mult: length};\n\n  enter[v] = update[v] = thickness;\n  thickness.offset = value(spec.labelOffset, config.gradientLabelOffset) || 0;\n\n  overlap = overlap ? {\n    separation: _('labelSeparation'),\n    method: overlap,\n    order: 'datum.' + Index\n  } : undefined;\n\n  // type, role, style, key, dataRef, encode, extras\n  return guideMark({\n    type:  TextMark,\n    role:  LegendLabelRole,\n    style: GuideLabelStyle,\n    key:   Value,\n    from: dataRef,\n    encode,\n    overlap\n  }, userEncode);\n}\n","import {\n  GuideLabelStyle, Index, Label, LegendScales, Offset, Size, Skip,\n  Value, one, zero\n} from './constants';\nimport guideGroup from './guide-group';\nimport guideMark from './guide-mark';\nimport {lookup} from './guide-util';\nimport {addEncoders, encoder, extendEncode} from '../encode/util';\nimport {SymbolMark, TextMark} from '../marks/marktypes';\nimport {LegendLabelRole, LegendSymbolRole, ScopeRole} from '../marks/roles';\n\n// userEncode is top-level, includes entries, symbols, labels\nexport default function(spec, config, userEncode, dataRef, columns) {\n  const _ = lookup(spec, config),\n        entries = userEncode.entries,\n        interactive = !!(entries && entries.interactive),\n        name = entries ? entries.name : undefined,\n        height = _('clipHeight'),\n        symbolOffset = _('symbolOffset'),\n        valueRef = {data: 'value'},\n        xSignal = `(${columns}) ? datum.${Offset} : datum.${Size}`,\n        yEncode = height ? encoder(height) : {field: Size},\n        index = `datum.${Index}`,\n        ncols = `max(1, ${columns})`;\n\n  let encode, enter, update, nrows, sort;\n\n  yEncode.mult = 0.5;\n\n  // -- LEGEND SYMBOLS --\n  encode = {\n    enter:  enter = {\n      opacity: zero,\n      x: {signal: xSignal, mult: 0.5, offset: symbolOffset},\n      y: yEncode\n    },\n    update: update = {\n      opacity: one,\n      x: enter.x,\n      y: enter.y\n    },\n    exit: {\n      opacity: zero\n    }\n  };\n\n  let baseFill = null,\n      baseStroke = null;\n  if (!spec.fill) {\n    baseFill = config.symbolBaseFillColor;\n    baseStroke = config.symbolBaseStrokeColor;\n  }\n\n  addEncoders(encode, {\n    fill:             _('symbolFillColor', baseFill),\n    shape:            _('symbolType'),\n    size:             _('symbolSize'),\n    stroke:           _('symbolStrokeColor', baseStroke),\n    strokeDash:       _('symbolDash'),\n    strokeDashOffset: _('symbolDashOffset'),\n    strokeWidth:      _('symbolStrokeWidth')\n  }, { // update\n    opacity:          _('symbolOpacity')\n  });\n\n  LegendScales.forEach(scale => {\n    if (spec[scale]) {\n      update[scale] = enter[scale] = {scale: spec[scale], field: Value};\n    }\n  });\n\n  const symbols = guideMark({\n    type: SymbolMark,\n    role: LegendSymbolRole,\n    key:  Value,\n    from: valueRef,\n    clip: height ? true : undefined,\n    encode\n  }, userEncode.symbols);\n\n  // -- LEGEND LABELS --\n  const labelOffset = encoder(symbolOffset);\n  labelOffset.offset = _('labelOffset');\n\n  encode = {\n    enter:  enter = {\n      opacity: zero,\n      x: {signal: xSignal, offset: labelOffset},\n      y: yEncode\n    },\n    update: update = {\n      opacity: one,\n      text: {field: Label},\n      x: enter.x,\n      y: enter.y\n    },\n    exit: {\n      opacity: zero\n    }\n  };\n\n  addEncoders(encode, {\n    align:       _('labelAlign'),\n    baseline:    _('labelBaseline'),\n    fill:        _('labelColor'),\n    fillOpacity: _('labelOpacity'),\n    font:        _('labelFont'),\n    fontSize:    _('labelFontSize'),\n    fontStyle:   _('labelFontStyle'),\n    fontWeight:  _('labelFontWeight'),\n    limit:       _('labelLimit')\n  });\n\n  const labels = guideMark({\n    type:  TextMark,\n    role:  LegendLabelRole,\n    style: GuideLabelStyle,\n    key:   Value,\n    from:  valueRef,\n    encode\n  }, userEncode.labels);\n\n  // -- LEGEND ENTRY GROUPS --\n  encode = {\n    enter: {\n      noBound: {value: !height}, // ignore width/height in bounds calc\n      width: zero,\n      height: height ? encoder(height) : zero,\n      opacity: zero\n    },\n    exit: {opacity: zero},\n    update: update = {\n      opacity: one,\n      row: {signal: null},\n      column: {signal: null}\n    }\n  };\n\n  // annotate and sort groups to ensure correct ordering\n  if (_.isVertical(true)) {\n    nrows = `ceil(item.mark.items.length / ${ncols})`;\n    update.row.signal = `${index}%${nrows}`;\n    update.column.signal = `floor(${index} / ${nrows})`;\n    sort = {field: ['row', index]};\n  } else {\n    update.row.signal = `floor(${index} / ${ncols})`;\n    update.column.signal = `${index} % ${ncols}`;\n    sort = {field: index};\n  }\n  // handle zero column case (implies infinite columns)\n  update.column.signal = `(${columns})?${update.column.signal}:${index}`;\n\n  // facet legend entries into sub-groups\n  dataRef = {facet: {data: dataRef, name: 'value', groupby: Index}};\n\n  return guideGroup({\n    role:   ScopeRole,\n    from:   dataRef,\n    encode: extendEncode(encode, entries, Skip),\n    marks:  [symbols, labels],\n    name,\n    interactive,\n    sort\n  });\n}\n\nexport function legendSymbolLayout(spec, config) {\n  const _ = lookup(spec, config);\n\n  // layout parameters for legend entries\n  return {\n    align:   _('gridAlign'),\n    columns: _.entryColumns(),\n    center:  {\n      row: true,\n      column: false\n    },\n    padding: {\n      row:    _('rowPadding'),\n      column: _('columnPadding')\n    }\n  };\n}\n","import {GuideTitleStyle, one, zero} from './constants';\nimport guideMark from './guide-mark';\nimport {alignExpr, anchorExpr, lookup} from './guide-util';\nimport {addEncoders} from '../encode/util';\nimport {TextMark} from '../marks/marktypes';\nimport {LegendTitleRole} from '../marks/roles';\n\n// expression logic for align, anchor, angle, and baseline calculation\nconst isL = 'item.orient === \"left\"',\n      isR = 'item.orient === \"right\"',\n      isLR = `(${isL} || ${isR})`,\n      isVG = `datum.vgrad && ${isLR}`,\n      baseline = anchorExpr('\"top\"', '\"bottom\"', '\"middle\"'),\n      alignFlip = anchorExpr('\"right\"', '\"left\"', '\"center\"'),\n      exprAlign = `datum.vgrad && ${isR} ? (${alignFlip}) : (${isLR} && !(datum.vgrad && ${isL})) ? \"left\" : ${alignExpr}`,\n      exprAnchor = `item._anchor || (${isLR} ? \"middle\" : \"start\")`,\n      exprAngle = `${isVG} ? (${isL} ? -90 : 90) : 0`,\n      exprBaseline = `${isLR} ? (datum.vgrad ? (${isR} ? \"bottom\" : \"top\") : ${baseline}) : \"top\"`;\n\nexport default function(spec, config, userEncode, dataRef) {\n  const _ = lookup(spec, config);\n\n  const encode = {\n    enter: {opacity: zero},\n    update: {\n      opacity: one,\n      x: {field: {group: 'padding'}},\n      y: {field: {group: 'padding'}}\n    },\n    exit: {opacity: zero}\n  };\n\n  addEncoders(encode, {\n    orient:      _('titleOrient'),\n    _anchor:     _('titleAnchor'),\n    anchor:      {signal: exprAnchor},\n    angle:       {signal: exprAngle},\n    align:       {signal: exprAlign},\n    baseline:    {signal: exprBaseline},\n    text:        spec.title,\n    fill:        _('titleColor'),\n    fillOpacity: _('titleOpacity'),\n    font:        _('titleFont'),\n    fontSize:    _('titleFontSize'),\n    fontStyle:   _('titleFontStyle'),\n    fontWeight:  _('titleFontWeight'),\n    limit:       _('titleLimit'),\n    lineHeight:  _('titleLineHeight')\n  }, { // require update\n    align:       _('titleAlign'),\n    baseline:    _('titleBaseline')\n  });\n\n  return guideMark({\n    type:  TextMark,\n    role:  LegendTitleRole,\n    style: GuideTitleStyle,\n    from:  dataRef,\n    encode\n  }, userEncode);\n}\n","import {isObject, stringValue} from 'vega-util';\n\nexport default function(clip, scope) {\n  let expr;\n\n  if (isObject(clip)) {\n    if (clip.signal) {\n      expr = clip.signal;\n    } else if (clip.path) {\n      expr = 'pathShape(' + param(clip.path) + ')';\n    } else if (clip.sphere) {\n      expr = 'geoShape(' + param(clip.sphere) + ', {type: \"Sphere\"})';\n    }\n  }\n\n  return expr\n    ? scope.signalRef(expr)\n    : !!clip;\n}\n\nfunction param(value) {\n  return isObject(value) && value.signal\n    ? value.signal\n    : stringValue(value);\n}","import {GroupMark} from './marktypes';\nimport {MarkRole, ScopeRole} from './roles';\n\nexport default function(spec) {\n  const role = spec.role || '';\n  return (!role.indexOf('axis') || !role.indexOf('legend') || !role.indexOf('title'))\n    ? role\n    : spec.type === GroupMark ? ScopeRole : (role || MarkRole);\n}\n","import role from './role';\n\nexport default function(spec) {\n  return {\n    marktype:     spec.type,\n    name:         spec.name || undefined,\n    role:         spec.role || role(spec),\n    zindex:       +spec.zindex || undefined,\n    aria:         spec.aria,\n    description:  spec.description\n  };\n}\n","export default function(spec, scope) {\n  return spec && spec.signal ? scope.signalRef(spec.signal)\n    : spec === false ? false\n    : true;\n}\n","import {Params} from '../transforms';\nimport {entry, fieldRef, isSignal, ref} from '../util';\nimport {definition} from 'vega-dataflow';\nimport {parseExpression} from 'vega-functions';\nimport {error, extend, isArray, isString, stringValue} from 'vega-util';\n\n/**\n * Parse a data transform specification.\n */\nexport default function(spec, scope) {\n  const def = definition(spec.type);\n  if (!def) error('Unrecognized transform type: ' + stringValue(spec.type));\n\n  const t = entry(def.type.toLowerCase(), null, parseParameters(def, spec, scope));\n  if (spec.signal) scope.addSignal(spec.signal, scope.proxy(t));\n  t.metadata = def.metadata || {};\n\n  return t;\n}\n\n/**\n * Parse all parameters of a data transform.\n */\nfunction parseParameters(def, spec, scope) {\n  const params = {},\n        n = def.params.length;\n\n  for (let i = 0; i < n; ++i) {\n    const pdef = def.params[i];\n    params[pdef.name] = parseParameter(pdef, spec, scope);\n  }\n  return params;\n}\n\n/**\n * Parse a data transform parameter.\n */\nfunction parseParameter(def, spec, scope) {\n  const type = def.type,\n        value = spec[def.name];\n\n  if (type === 'index') {\n    return parseIndexParameter(def, spec, scope);\n  } else if (value === undefined) {\n    if (def.required) {\n      error('Missing required ' + stringValue(spec.type)\n          + ' parameter: ' + stringValue(def.name));\n    }\n    return;\n  } else if (type === 'param') {\n    return parseSubParameters(def, spec, scope);\n  } else if (type === 'projection') {\n    return scope.projectionRef(spec[def.name]);\n  }\n\n  return def.array && !isSignal(value)\n    ? value.map(v => parameterValue(def, v, scope))\n    : parameterValue(def, value, scope);\n}\n\n/**\n * Parse a single parameter value.\n */\nfunction parameterValue(def, value, scope) {\n  const type = def.type;\n\n  if (isSignal(value)) {\n    return isExpr(type) ? error('Expression references can not be signals.')\n         : isField(type) ? scope.fieldRef(value)\n         : isCompare(type) ? scope.compareRef(value)\n         : scope.signalRef(value.signal);\n  } else {\n    const expr = def.expr || isField(type);\n    return expr && outerExpr(value) ? scope.exprRef(value.expr, value.as)\n         : expr && outerField(value) ? fieldRef(value.field, value.as)\n         : isExpr(type) ? parseExpression(value, scope)\n         : isData(type) ? ref(scope.getData(value).values)\n         : isField(type) ? fieldRef(value)\n         : isCompare(type) ? scope.compareRef(value)\n         : value;\n  }\n}\n\n/**\n * Parse parameter for accessing an index of another data set.\n */\nfunction parseIndexParameter(def, spec, scope) {\n  if (!isString(spec.from)) {\n    error('Lookup \"from\" parameter must be a string literal.');\n  }\n  return scope.getData(spec.from).lookupRef(scope, spec.key);\n}\n\n/**\n * Parse a parameter that contains one or more sub-parameter objects.\n */\nfunction parseSubParameters(def, spec, scope) {\n  const value = spec[def.name];\n\n  if (def.array) {\n    if (!isArray(value)) { // signals not allowed!\n      error('Expected an array of sub-parameters. Instead: ' + stringValue(value));\n    }\n    return value.map(v => parseSubParameter(def, v, scope));\n  } else {\n    return parseSubParameter(def, value, scope);\n  }\n}\n\n/**\n * Parse a sub-parameter object.\n */\nfunction parseSubParameter(def, value, scope) {\n  const n =def.params.length;\n  let pdef;\n\n  // loop over defs to find matching key\n  for (let i = 0; i < n; ++i) {\n    pdef = def.params[i];\n    for (const k in pdef.key) {\n      if (pdef.key[k] !== value[k]) { pdef = null; break; }\n    }\n    if (pdef) break;\n  }\n  // raise error if matching key not found\n  if (!pdef) error('Unsupported parameter: ' + stringValue(value));\n\n  // parse params, create Params transform, return ref\n  const params = extend(parseParameters(pdef, value, scope), pdef.key);\n  return ref(scope.add(Params(params)));\n}\n\n// -- Utilities -----\n\nexport const outerExpr = _ => _ && _.expr;\n\nexport const outerField = _ => _ && _.field;\n\nexport const isData = _ => _ === 'data';\n\nexport const isExpr = _ => _ === 'expr';\n\nexport const isField = _ => _ === 'field';\n\nexport const isCompare = _ => _ === 'compare';\n","import parseTransform from '../transform';\nimport {Collect} from '../../transforms';\nimport {ref} from '../../util';\nimport {array, error, extend} from 'vega-util';\n\nexport default function(from, group, scope) {\n  let facet, key, op, dataRef, parent;\n\n  // if no source data, generate singleton datum\n  if (!from) {\n    dataRef = ref(scope.add(Collect(null, [{}])));\n  }\n\n  // if faceted, process facet specification\n  else if (facet = from.facet) {\n    if (!group) error('Only group marks can be faceted.');\n\n    // use pre-faceted source data, if available\n    if (facet.field != null) {\n      dataRef = parent = getDataRef(facet, scope);\n    } else {\n      // generate facet aggregates if no direct data specification\n      if (!from.data) {\n        op = parseTransform(extend({\n          type:    'aggregate',\n          groupby: array(facet.groupby)\n        }, facet.aggregate), scope);\n        op.params.key = scope.keyRef(facet.groupby);\n        op.params.pulse = getDataRef(facet, scope);\n        dataRef = parent = ref(scope.add(op));\n      } else {\n        parent = ref(scope.getData(from.data).aggregate);\n      }\n\n      key = scope.keyRef(facet.groupby, true);\n    }\n  }\n\n  // if not yet defined, get source data reference\n  if (!dataRef) {\n    dataRef = getDataRef(from, scope);\n  }\n\n  return {\n    key: key,\n    pulse: dataRef,\n    parent: parent\n  };\n}\n\nexport function getDataRef(from, scope) {\n  return from.$ref ? from\n    : from.data && from.data.$ref ? from.data\n    : ref(scope.getData(from.data).output);\n}","import {Aggregate, Collect} from './transforms';\nimport {aggrField, entry, keyFieldRef, ref, sortKey} from './util';\nimport {isString} from 'vega-util';\n\nexport default function DataScope(scope, input, output, values, aggr) {\n  this.scope = scope;   // parent scope object\n  this.input = input;   // first operator in pipeline (tuple input)\n  this.output = output; // last operator in pipeline (tuple output)\n  this.values = values; // operator for accessing tuples (but not tuple flow)\n\n  // last aggregate in transform pipeline\n  this.aggregate = aggr;\n\n  // lookup table of field indices\n  this.index = {};\n}\n\nDataScope.fromEntries = function(scope, entries) {\n  const n = entries.length,\n        values = entries[n-1],\n        output = entries[n-2];\n\n  let input = entries[0],\n      aggr = null,\n      i = 1;\n\n  if (input && input.type === 'load') {\n    input = entries[1];\n  }\n\n  // add operator entries to this scope, wire up pulse chain\n  scope.add(entries[0]);\n  for (; i<n; ++i) {\n    entries[i].params.pulse = ref(entries[i-1]);\n    scope.add(entries[i]);\n    if (entries[i].type === 'aggregate') aggr = entries[i];\n  }\n\n  return new DataScope(scope, input, output, values, aggr);\n};\n\nfunction fieldKey(field) {\n  return isString(field) ? field : null;\n}\n\nfunction addSortField(scope, p, sort) {\n  const as = aggrField(sort.op, sort.field);\n  let s;\n\n  if (p.ops) {\n    for (let i = 0, n = p.as.length; i < n; ++i) {\n      if (p.as[i] === as) return;\n    }\n  } else {\n    p.ops = ['count'];\n    p.fields = [null];\n    p.as = ['count'];\n  }\n  if (sort.op) {\n    p.ops.push((s=sort.op.signal) ? scope.signalRef(s) : sort.op);\n    p.fields.push(scope.fieldRef(sort.field));\n    p.as.push(as);\n  }\n}\n\nfunction cache(scope, ds, name, optype, field, counts, index) {\n  const cache = ds[name] || (ds[name] = {}),\n        sort = sortKey(counts);\n\n  let k = fieldKey(field),\n      v, op;\n\n  if (k != null) {\n    scope = ds.scope;\n    k = k + (sort ? '|' + sort : '');\n    v = cache[k];\n  }\n\n  if (!v) {\n    const params = counts\n      ? {field: keyFieldRef, pulse: ds.countsRef(scope, field, counts)}\n      : {field: scope.fieldRef(field), pulse: ref(ds.output)};\n    if (sort) params.sort = scope.sortRef(counts);\n    op = scope.add(entry(optype, undefined, params));\n    if (index) ds.index[field] = op;\n    v = ref(op);\n    if (k != null) cache[k] = v;\n  }\n  return v;\n}\n\nDataScope.prototype = {\n  countsRef(scope, field, sort) {\n    const ds = this,\n          cache = ds.counts || (ds.counts = {}),\n          k = fieldKey(field);\n\n    let v, a, p;\n\n    if (k != null) {\n      scope = ds.scope;\n      v = cache[k];\n    }\n\n    if (!v) {\n      p = {\n        groupby: scope.fieldRef(field, 'key'),\n        pulse: ref(ds.output)\n      };\n      if (sort && sort.field) addSortField(scope, p, sort);\n      a = scope.add(Aggregate(p));\n      v = scope.add(Collect({pulse: ref(a)}));\n      v = {agg: a, ref: ref(v)};\n      if (k != null) cache[k] = v;\n    } else if (sort && sort.field) {\n      addSortField(scope, v.agg.params, sort);\n    }\n\n    return v.ref;\n  },\n\n  tuplesRef() {\n    return ref(this.values);\n  },\n\n  extentRef(scope, field) {\n    return cache(scope, this, 'extent', 'extent', field, false);\n  },\n\n  domainRef(scope, field) {\n    return cache(scope, this, 'domain', 'values', field, false);\n  },\n\n  valuesRef(scope, field, sort) {\n    return cache(scope, this, 'vals', 'values', field, sort || true);\n  },\n\n  lookupRef(scope, field) {\n    return cache(scope, this, 'lookup', 'tupleindex', field, false);\n  },\n\n  indataRef(scope, field) {\n    return cache(scope, this, 'indata', 'tupleindex', field, true, true);\n  }\n};\n","import {operator} from '../util';\nimport {parseExpression} from 'vega-functions';\n\nexport default function(spec, scope, name) {\n  const remove = spec.remove,\n        insert = spec.insert,\n        toggle = spec.toggle,\n        modify = spec.modify,\n        values = spec.values,\n        op = scope.add(operator());\n\n  const update = 'if(' + spec.trigger + ',modify(\"'\n    + name + '\",'\n    + [insert, remove, toggle, modify, values]\n        .map(_ => _ == null ? 'null' : _)\n        .join(',')\n    + '),0)';\n\n  const expr = parseExpression(update, scope);\n  op.update = expr.$expr;\n  op.params = expr.$params;\n}\n","import parseEncode from './encode';\nimport clip from './marks/clip';\nimport definition from './marks/definition';\nimport interactive from './marks/interactive';\nimport parseData from './marks/data';\nimport parseFacet from './marks/facet';\nimport parseSubflow from './marks/subflow';\nimport getRole from './marks/role';\nimport {GroupMark} from './marks/marktypes';\nimport {FrameRole, MarkRole, ScopeRole} from './marks/roles';\nimport parseTransform from './transform';\nimport parseTrigger from './trigger';\nimport DataScope from '../DataScope';\nimport {fieldRef, isSignal, ref} from '../util';\nimport {error} from 'vega-util';\nimport {Bound, Collect, DataJoin, Encode, Mark, Overlap, Render, Sieve, SortItems, ViewLayout} from '../transforms';\n\nexport default function(spec, scope) {\n  const role = getRole(spec),\n        group = spec.type === GroupMark,\n        facet = spec.from && spec.from.facet,\n        overlap = spec.overlap;\n\n  let layout = spec.layout || role === ScopeRole || role === FrameRole,\n      ops, op, store, enc, name, layoutRef, boundRef;\n\n  const nested = role === MarkRole || layout || facet;\n\n  // resolve input data\n  const input = parseData(spec.from, group, scope);\n\n  // data join to map tuples to visual items\n  op = scope.add(DataJoin({\n    key:   input.key || (spec.key ? fieldRef(spec.key) : undefined),\n    pulse: input.pulse,\n    clean: !group\n  }));\n  const joinRef = ref(op);\n\n  // collect visual items\n  op = store = scope.add(Collect({pulse: joinRef}));\n\n  // connect visual items to scenegraph\n  op = scope.add(Mark({\n    markdef:     definition(spec),\n    interactive: interactive(spec.interactive, scope),\n    clip:        clip(spec.clip, scope),\n    context:     {$context: true},\n    groups:      scope.lookup(),\n    parent:      scope.signals.parent ? scope.signalRef('parent') : null,\n    index:       scope.markpath(),\n    pulse:       ref(op)\n  }));\n  const markRef = ref(op);\n\n  // add visual encoders\n  op = enc = scope.add(Encode(parseEncode(\n    spec.encode, spec.type, role, spec.style, scope,\n    {mod: false, pulse: markRef}\n  )));\n\n  // monitor parent marks to propagate changes\n  op.params.parent = scope.encode();\n\n  // add post-encoding transforms, if defined\n  if (spec.transform) {\n    spec.transform.forEach(_ => {\n      const tx = parseTransform(_, scope),\n            md = tx.metadata;\n      if (md.generates || md.changes) {\n        error('Mark transforms should not generate new data.');\n      }\n      if (!md.nomod) enc.params.mod = true; // update encode mod handling\n      tx.params.pulse = ref(op);\n      scope.add(op = tx);\n    });\n  }\n\n  // if item sort specified, perform post-encoding\n  if (spec.sort) {\n    op = scope.add(SortItems({\n      sort:  scope.compareRef(spec.sort),\n      pulse: ref(op)\n    }));\n  }\n\n  const encodeRef = ref(op);\n\n  // add view layout operator if needed\n  if (facet || layout) {\n    layout = scope.add(ViewLayout({\n      layout:   scope.objectProperty(spec.layout),\n      legends:  scope.legends,\n      mark:     markRef,\n      pulse:    encodeRef\n    }));\n    layoutRef = ref(layout);\n  }\n\n  // compute bounding boxes\n  const bound = scope.add(Bound({mark: markRef, pulse: layoutRef || encodeRef}));\n  boundRef = ref(bound);\n\n  // if group mark, recurse to parse nested content\n  if (group) {\n    // juggle layout & bounds to ensure they run *after* any faceting transforms\n    if (nested) { ops = scope.operators; ops.pop(); if (layout) ops.pop(); }\n\n    scope.pushState(encodeRef, layoutRef || boundRef, joinRef);\n    facet ? parseFacet(spec, scope, input)          // explicit facet\n        : nested ? parseSubflow(spec, scope, input) // standard mark group\n        : scope.parse(spec); // guide group, we can avoid nested scopes\n    scope.popState();\n\n    if (nested) { if (layout) ops.push(layout); ops.push(bound); }\n  }\n\n  // if requested, add overlap removal transform\n  if (overlap) {\n    boundRef = parseOverlap(overlap, boundRef, scope);\n  }\n\n  // render / sieve items\n  const render = scope.add(Render({pulse: boundRef})),\n        sieve = scope.add(Sieve({pulse: ref(render)}, undefined, scope.parent()));\n\n  // if mark is named, make accessible as reactive geometry\n  // add trigger updates if defined\n  if (spec.name != null) {\n    name = spec.name;\n    scope.addData(name, new DataScope(scope, store, render, sieve));\n    if (spec.on) spec.on.forEach(on => {\n      if (on.insert || on.remove || on.toggle) {\n        error('Marks only support modify triggers.');\n      }\n      parseTrigger(on, scope, name);\n    });\n  }\n}\n\nfunction parseOverlap(overlap, source, scope) {\n  const method = overlap.method,\n        bound = overlap.bound,\n        sep = overlap.separation;\n\n  const params = {\n    separation: isSignal(sep) ? scope.signalRef(sep.signal) : sep,\n    method: isSignal(method) ? scope.signalRef(method.signal) : method,\n    pulse:  source\n  };\n\n  if (overlap.order) {\n    params.sort = scope.compareRef({field: overlap.order});\n  }\n\n  if (bound) {\n    const tol = bound.tolerance;\n    params.boundTolerance = isSignal(tol) ? scope.signalRef(tol.signal) : +tol;\n    params.boundScale = scope.scaleRef(bound.scale);\n    params.boundOrient = bound.orient;\n  }\n\n  return ref(scope.add(Overlap(params)));\n}\n","import {getDataRef} from './data';\nimport DataScope from '../../DataScope';\nimport {Collect, Facet, PreFacet, Sieve} from '../../transforms';\nimport {ref} from '../../util';\nimport {error, stringValue} from 'vega-util';\n\nexport default function(spec, scope, group) {\n  const facet = spec.from.facet,\n        name = facet.name,\n        data = getDataRef(facet, scope);\n  let op;\n\n  if (!facet.name) {\n    error('Facet must have a name: ' + stringValue(facet));\n  }\n  if (!facet.data) {\n    error('Facet must reference a data set: ' + stringValue(facet));\n  }\n\n  if (facet.field) {\n    op = scope.add(PreFacet({\n      field: scope.fieldRef(facet.field),\n      pulse: data\n    }));\n  } else if (facet.groupby) {\n    op = scope.add(Facet({\n      key:   scope.keyRef(facet.groupby),\n      group: ref(scope.proxy(group.parent)),\n      pulse: data\n    }));\n  } else {\n    error('Facet must specify groupby or field: ' + stringValue(facet));\n  }\n\n  // initialize facet subscope\n  const subscope = scope.fork(),\n        source = subscope.add(Collect()),\n        values = subscope.add(Sieve({pulse: ref(source)}));\n  subscope.addData(name, new DataScope(subscope, source, source, values));\n  subscope.addSignal('parent', null);\n\n  // parse faceted subflow\n  op.params.subflow = {\n    $subflow: subscope.parse(spec).toRuntime()\n  };\n}\n","import {PreFacet, Sieve} from '../../transforms';\n\nexport default function(spec, scope, input) {\n  const op = scope.add(PreFacet({pulse: input.pulse})),\n        subscope = scope.fork();\n\n  subscope.add(Sieve());\n  subscope.addSignal('parent', null);\n\n  // parse group mark subflow\n  op.params.subflow = {\n    $subflow: subscope.parse(spec).toRuntime()\n  };\n}\n","import {addEncoders, extendEncode} from './encode/util';\nimport {\n  Discrete, Gradient,\n  GuideLabelStyle, LegendScales, Skip, Symbols\n} from './guides/constants';\nimport guideGroup from './guides/guide-group';\nimport {getEncoding, getStyle, lookup} from './guides/guide-util';\nimport legendGradient from './guides/legend-gradient';\nimport legendGradientDiscrete from './guides/legend-gradient-discrete';\nimport legendGradientLabels from './guides/legend-gradient-labels';\nimport legendSymbolGroups, {legendSymbolLayout} from './guides/legend-symbol-groups';\nimport legendTitle from './guides/legend-title';\nimport parseMark from './mark';\nimport {LegendEntryRole, LegendRole} from './marks/roles';\n\nimport {deref, ref} from '../util';\nimport {Collect, LegendEntries} from '../transforms';\n\nimport {parseExpression} from 'vega-functions';\nimport {isContinuous, isDiscretizing} from 'vega-scale';\nimport {error} from 'vega-util';\n\nexport default function(spec, scope) {\n  const config = scope.config.legend,\n        encode = spec.encode || {},\n        _ = lookup(spec, config),\n        legendEncode = encode.legend || {},\n        name = legendEncode.name || undefined,\n        interactive = legendEncode.interactive,\n        style = legendEncode.style,\n        scales = {};\n\n  let scale = 0, entryLayout, params, children;\n\n  // resolve scales and 'canonical' scale name\n  LegendScales.forEach(s => spec[s]\n    ? (scales[s] = spec[s], scale = scale || spec[s]) : 0\n  );\n  if (!scale) error('Missing valid scale for legend.');\n\n  // resolve legend type (symbol, gradient, or discrete gradient)\n  const type = legendType(spec, scope.scaleType(scale));\n\n  // single-element data source for legend group\n  const datum = {\n    title:  spec.title != null,\n    scales: scales,\n    type:   type,\n    vgrad:  type !== 'symbol' &&  _.isVertical()\n  };\n  const dataRef = ref(scope.add(Collect(null, [datum])));\n\n  // encoding properties for legend entry sub-group\n  const entryEncode = {enter: {x: {value: 0}, y: {value: 0}}};\n\n  // data source for legend values\n  const entryRef = ref(scope.add(LegendEntries(params = {\n    type:    type,\n    scale:   scope.scaleRef(scale),\n    count:   scope.objectProperty(_('tickCount')),\n    limit:   scope.property(_('symbolLimit')),\n    values:  scope.objectProperty(spec.values),\n    minstep: scope.property(spec.tickMinStep),\n    formatType: scope.property(spec.formatType),\n    formatSpecifier: scope.property(spec.format)\n  })));\n\n  // continuous gradient legend\n  if (type === Gradient) {\n    children = [\n      legendGradient(spec, scale, config, encode.gradient),\n      legendGradientLabels(spec, config, encode.labels, entryRef)\n    ];\n    // adjust default tick count based on the gradient length\n    params.count = params.count || scope.signalRef(\n      `max(2,2*floor((${deref(_.gradientLength())})/100))`\n    );\n  }\n\n  // discrete gradient legend\n  else if (type === Discrete) {\n    children = [\n      legendGradientDiscrete(spec, scale, config, encode.gradient, entryRef),\n      legendGradientLabels(spec, config, encode.labels, entryRef)\n    ];\n  }\n\n  // symbol legend\n  else {\n    // determine legend symbol group layout\n    entryLayout = legendSymbolLayout(spec, config);\n    children = [\n      legendSymbolGroups(spec, config, encode, entryRef, deref(entryLayout.columns))\n    ];\n    // pass symbol size information to legend entry generator\n    params.size = sizeExpression(spec, scope, children[0].marks);\n  }\n\n  // generate legend marks\n  children = [\n    guideGroup({\n      role: LegendEntryRole,\n      from: dataRef,\n      encode: entryEncode,\n      marks: children,\n      layout: entryLayout,\n      interactive\n    })\n  ];\n\n  // include legend title if defined\n  if (datum.title) {\n    children.push(legendTitle(spec, config, encode.title, dataRef));\n  }\n\n  // parse legend specification\n  return parseMark(\n    guideGroup({\n      role:        LegendRole,\n      from:        dataRef,\n      encode:      extendEncode(buildLegendEncode(_, spec, config), legendEncode, Skip),\n      marks:       children,\n      aria:        _('aria'),\n      description: _('description'),\n      zindex:      _('zindex'),\n      name,\n      interactive,\n      style\n    }),\n    scope\n  );\n}\n\nfunction legendType(spec, scaleType) {\n  let type = spec.type || Symbols;\n\n  if (!spec.type && scaleCount(spec) === 1 && (spec.fill || spec.stroke)) {\n    type = isContinuous(scaleType) ? Gradient\n      : isDiscretizing(scaleType) ? Discrete\n      : Symbols;\n  }\n\n  return type !== Gradient ? type\n    : isDiscretizing(scaleType) ? Discrete\n    : Gradient;\n}\n\nfunction scaleCount(spec) {\n  return LegendScales.reduce((count, type) => count + (spec[type] ? 1 : 0), 0);\n}\n\nfunction buildLegendEncode(_, spec, config) {\n  const encode = {enter: {}, update: {}};\n\n  addEncoders(encode, {\n    orient:       _('orient'),\n    offset:       _('offset'),\n    padding:      _('padding'),\n    titlePadding: _('titlePadding'),\n    cornerRadius: _('cornerRadius'),\n    fill:         _('fillColor'),\n    stroke:       _('strokeColor'),\n    strokeWidth:  config.strokeWidth,\n    strokeDash:   config.strokeDash,\n    x:            _('legendX'),\n    y:            _('legendY'),\n\n    // accessibility support\n    format:       spec.format,\n    formatType:   spec.formatType\n  });\n\n  return encode;\n}\n\nfunction sizeExpression(spec, scope, marks) {\n  const size = deref(getChannel('size', spec, marks)),\n        strokeWidth = deref(getChannel('strokeWidth', spec, marks)),\n        fontSize = deref(getFontSize(marks[1].encode, scope, GuideLabelStyle));\n\n  return parseExpression(\n    `max(ceil(sqrt(${size})+${strokeWidth}),${fontSize})`,\n    scope\n  );\n}\n\nfunction getChannel(name, spec, marks) {\n  return spec[name]\n    ? `scale(\"${spec[name]}\",datum)`\n    : getEncoding(name, marks[0].encode);\n}\n\nfunction getFontSize(encode, scope, style) {\n  return getEncoding('fontSize', encode) || getStyle('fontSize', scope, style);\n}\n","import {addEncoders, extendEncode} from './encode/util';\nimport {GroupSubtitleStyle, GroupTitleStyle, Left, Right, Skip} from './guides/constants';\nimport guideGroup from './guides/guide-group';\nimport guideMark from './guides/guide-mark';\nimport {alignExpr, lookup} from './guides/guide-util';\nimport parseMark from './mark';\nimport {TextMark} from './marks/marktypes';\nimport {TitleRole, TitleSubtitleRole, TitleTextRole} from './marks/roles';\nimport {Collect} from '../transforms';\nimport {ref} from '../util';\nimport {extend, isString} from 'vega-util';\n\nconst angleExpr = `item.orient===\"${Left}\"?-90:item.orient===\"${Right}\"?90:0`;\n\nexport default function(spec, scope) {\n  spec = isString(spec) ? {text: spec} : spec;\n\n  const _ = lookup(spec, scope.config.title),\n        encode = spec.encode || {},\n        userEncode = encode.group || {},\n        name = userEncode.name || undefined,\n        interactive = userEncode.interactive,\n        style = userEncode.style,\n        children = [];\n\n  // single-element data source for group title\n  const datum = {},\n        dataRef = ref(scope.add(Collect(null, [datum])));\n\n  // include title text\n  children.push(buildTitle(spec, _, titleEncode(spec), dataRef));\n\n  // include subtitle text\n  if (spec.subtitle) {\n    children.push(buildSubTitle(spec, _, encode.subtitle, dataRef));\n  }\n\n  // parse title specification\n  return parseMark(\n    guideGroup({\n      role:        TitleRole,\n      from:        dataRef,\n      encode:      groupEncode(_, userEncode),\n      marks:       children,\n      aria:        _('aria'),\n      description: _('description'),\n      zindex:      _('zindex'),\n      name,\n      interactive,\n      style\n    }),\n    scope\n  );\n}\n\n// provide backwards-compatibility for title custom encode;\n// the top-level encode block has been *deprecated*.\nfunction titleEncode(spec) {\n  const encode = spec.encode;\n  return (encode && encode.title) || extend({\n    name: spec.name,\n    interactive: spec.interactive,\n    style: spec.style\n  }, encode);\n}\n\nfunction groupEncode(_, userEncode) {\n  const encode = {enter: {}, update: {}};\n\n  addEncoders(encode, {\n    orient:      _('orient'),\n    anchor:      _('anchor'),\n    align:       {signal: alignExpr},\n    angle:       {signal: angleExpr},\n    limit:       _('limit'),\n    frame:       _('frame'),\n    offset:      _('offset') || 0,\n    padding:     _('subtitlePadding')\n  });\n\n  return extendEncode(encode, userEncode, Skip);\n}\n\nfunction buildTitle(spec, _, userEncode, dataRef) {\n  const zero = {value: 0},\n        text = spec.text,\n        encode = {\n          enter: {opacity: zero},\n          update: {opacity: {value: 1}},\n          exit: {opacity: zero}\n        };\n\n  addEncoders(encode, {\n    text:       text,\n    align:      {signal: 'item.mark.group.align'},\n    angle:      {signal: 'item.mark.group.angle'},\n    limit:      {signal: 'item.mark.group.limit'},\n    baseline:   'top',\n    dx:         _('dx'),\n    dy:         _('dy'),\n    fill:       _('color'),\n    font:       _('font'),\n    fontSize:   _('fontSize'),\n    fontStyle:  _('fontStyle'),\n    fontWeight: _('fontWeight'),\n    lineHeight: _('lineHeight')\n  }, { // update\n    align:      _('align'),\n    angle:      _('angle'),\n    baseline:   _('baseline')\n  });\n\n  return guideMark({\n    type: TextMark,\n    role: TitleTextRole,\n    style: GroupTitleStyle,\n    from: dataRef,\n    encode\n  }, userEncode);\n}\n\nfunction buildSubTitle(spec, _, userEncode, dataRef) {\n  const zero = {value: 0},\n        text = spec.subtitle,\n        encode = {\n          enter: {opacity: zero},\n          update: {opacity: {value: 1}},\n          exit: {opacity: zero}\n        };\n\n  addEncoders(encode, {\n    text:       text,\n    align:      {signal: 'item.mark.group.align'},\n    angle:      {signal: 'item.mark.group.angle'},\n    limit:      {signal: 'item.mark.group.limit'},\n    baseline:   'top',\n    dx:         _('dx'),\n    dy:         _('dy'),\n    fill:       _('subtitleColor'),\n    font:       _('subtitleFont'),\n    fontSize:   _('subtitleFontSize'),\n    fontStyle:  _('subtitleFontStyle'),\n    fontWeight: _('subtitleFontWeight'),\n    lineHeight: _('subtitleLineHeight')\n  }, { // update\n    align:      _('align'),\n    angle:      _('angle'),\n    baseline:   _('baseline')\n  });\n\n  return guideMark({\n    type:  TextMark,\n    role:  TitleSubtitleRole,\n    style: GroupSubtitleStyle,\n    from:  dataRef,\n    encode\n  }, userEncode);\n}\n","import parseTransform from './transform';\nimport parseTrigger from './trigger';\nimport {Collect, Load, Relay, Sieve} from '../transforms';\nimport {hasSignal, isSignal, ref} from '../util';\nimport {array} from 'vega-util';\n\nexport default function parseData(data, scope) {\n  const transforms = [];\n\n  if (data.transform) {\n    data.transform.forEach(tx => {\n      transforms.push(parseTransform(tx, scope));\n    });\n  }\n\n  if (data.on) {\n    data.on.forEach(on => {\n      parseTrigger(on, scope, data.name);\n    });\n  }\n\n  scope.addDataPipeline(data.name, analyze(data, scope, transforms));\n}\n\n/**\n * Analyze a data pipeline, add needed operators.\n */\nfunction analyze(data, scope, ops) {\n  const output = [];\n  let source = null,\n      modify = false,\n      generate = false,\n      upstream, i, n, t, m;\n\n  if (data.values) {\n    // hard-wired input data set\n    if (isSignal(data.values) || hasSignal(data.format)) {\n      // if either values is signal or format has signal, use dynamic loader\n      output.push(load(scope, data));\n      output.push(source = collect());\n    } else {\n      // otherwise, ingest upon dataflow init\n      output.push(source = collect({\n        $ingest: data.values,\n        $format: data.format\n      }));\n    }\n  } else if (data.url) {\n    // load data from external source\n    if (hasSignal(data.url) || hasSignal(data.format)) {\n      // if either url or format has signal, use dynamic loader\n      output.push(load(scope, data));\n      output.push(source = collect());\n    } else {\n      // otherwise, request load upon dataflow init\n      output.push(source = collect({\n        $request: data.url,\n        $format: data.format\n      }));\n    }\n  } else if (data.source) {\n    // derives from one or more other data sets\n    source = upstream = array(data.source)\n      .map(d => ref(scope.getData(d).output));\n    output.push(null); // populate later\n  }\n\n  // scan data transforms, add collectors as needed\n  for (i=0, n=ops.length; i<n; ++i) {\n    t = ops[i];\n    m = t.metadata;\n\n    if (!source && !m.source) {\n      output.push(source = collect());\n    }\n    output.push(t);\n\n    if (m.generates) generate = true;\n    if (m.modifies && !generate) modify = true;\n\n    if (m.source) source = t;\n    else if (m.changes) source = null;\n  }\n\n  if (upstream) {\n    n = upstream.length - 1;\n    output[0] = Relay({\n      derive: modify,\n      pulse: n ? upstream : upstream[0]\n    });\n    if (modify || n) {\n      // collect derived and multi-pulse tuples\n      output.splice(1, 0, collect());\n    }\n  }\n\n  if (!source) output.push(collect());\n  output.push(Sieve({}));\n  return output;\n}\n\nfunction collect(values) {\n  const s = Collect({}, values);\n  s.metadata = {source: true};\n  return s;\n}\n\nfunction load(scope, data) {\n  return Load({\n    url:    data.url ? scope.property(data.url) : undefined,\n    async:  data.async ? scope.property(data.async) : undefined,\n    values: data.values ? scope.property(data.values) : undefined,\n    format: scope.objectProperty(data.format)\n  });\n}\n","import {extend, stringValue} from 'vega-util';\nimport {Bottom, Left, Right, Top} from './constants';\nimport {encoder} from '../encode/util';\nimport {isSignal} from '../../util';\n\nconst isX = orient => orient === Bottom || orient === Top;\n\n// get sign coefficient based on axis orient\nexport const getSign = (orient, a, b) => isSignal(orient)\n  ? ifLeftTopExpr(orient.signal, a, b)\n  : orient === Left || orient === Top ? a : b;\n\n// condition on axis x-direction\nexport const ifX = (orient, a, b) => isSignal(orient)\n  ? ifXEnc(orient.signal, a, b)\n  : isX(orient) ? a : b;\n\n// condition on axis y-direction\nexport const ifY = (orient, a, b) => isSignal(orient)\n  ? ifYEnc(orient.signal, a, b)\n  : isX(orient) ? b : a;\n\nexport const ifTop = (orient, a, b) => isSignal(orient)\n  ? ifTopExpr(orient.signal, a, b)\n  : orient === Top ? {value: a} : {value: b};\n\nexport const ifRight = (orient, a, b) => isSignal(orient)\n  ? ifRightExpr(orient.signal, a, b)\n  : orient === Right ? {value: a} : {value: b};\n\nconst ifXEnc = ($orient, a, b) => ifEnc(\n  `${$orient} === '${Top}' || ${$orient} === '${Bottom}'`, a, b\n);\n\nconst ifYEnc = ($orient, a, b) => ifEnc(\n  `${$orient} !== '${Top}' && ${$orient} !== '${Bottom}'`, a, b\n);\n\nconst ifLeftTopExpr = ($orient, a, b) => ifExpr(\n  `${$orient} === '${Left}' || ${$orient} === '${Top}'`, a, b\n);\n\nconst ifTopExpr = ($orient, a, b) => ifExpr(\n  `${$orient} === '${Top}'`, a, b\n);\n\nconst ifRightExpr = ($orient, a, b) => ifExpr(\n  `${$orient} === '${Right}'`, a, b\n);\n\nconst ifEnc = (test, a, b) => {\n  // ensure inputs are encoder objects (or null)\n  a = a != null ? encoder(a) : a;\n  b = b != null ? encoder(b) : b;\n\n  if (isSimple(a) && isSimple(b)) {\n    // if possible generate simple signal expression\n    a = a ? (a.signal || stringValue(a.value)) : null;\n    b = b ? (b.signal || stringValue(b.value)) : null;\n    return {signal: `${test} ? (${a}) : (${b})`};\n  } else {\n    // otherwise generate rule set\n    return [extend({test}, a)].concat(b || []);\n  }\n};\n\nconst isSimple = enc => (\n  enc == null || Object.keys(enc).length === 1\n);\n\nconst ifExpr = (test, a, b) => ({\n  signal: `${test} ? (${toExpr(a)}) : (${toExpr(b)})`\n});\n\nexport const ifOrient = ($orient, t, b, l, r) => ({\n  signal: (l != null ? `${$orient} === '${Left}' ? (${toExpr(l)}) : ` : '')\n        + (b != null ? `${$orient} === '${Bottom}' ? (${toExpr(b)}) : ` : '')\n        + (r != null ? `${$orient} === '${Right}' ? (${toExpr(r)}) : ` : '')\n        + (t != null ? `${$orient} === '${Top}' ? (${toExpr(t)}) : ` : '')\n        + '(null)'\n});\n\nconst toExpr = v => isSignal(v)\n  ? v.signal\n  : v == null ? null : stringValue(v);\n\nexport const mult = (sign, value) => value === 0 ? 0 : isSignal(sign)\n  ? {signal: `(${sign.signal}) * ${value}`}\n  : {value: sign * value};\n\nexport const patch = (value, base) => {\n  const s = value.signal;\n  return s && s.endsWith('(null)')\n    ? {signal: s.slice(0, -6) + base.signal}\n    : value;\n};\n","import {ifOrient, ifX} from './axis-util';\nimport {Bottom, GuideLabelStyle, GuideTitleStyle, Top} from './constants';\nimport {isSignal} from '../../util';\nimport {extend, hasOwnProperty} from 'vega-util';\n\nfunction fallback(prop, config, axisConfig, style) {\n  let styleProp;\n\n  if (config && hasOwnProperty(config, prop)) {\n    return config[prop];\n  }\n  else if (hasOwnProperty(axisConfig, prop)) {\n    return axisConfig[prop];\n  }\n  else if (prop.startsWith('title')) {\n    switch (prop) {\n      case 'titleColor':\n        styleProp = 'fill';\n        break;\n      case 'titleFont':\n      case 'titleFontSize':\n      case 'titleFontWeight':\n        styleProp = prop[5].toLowerCase() + prop.slice(6);\n    }\n    return style[GuideTitleStyle][styleProp];\n  }\n  else if (prop.startsWith('label')) {\n    switch (prop) {\n      case 'labelColor':\n        styleProp = 'fill';\n        break;\n      case 'labelFont':\n      case 'labelFontSize':\n        styleProp = prop[5].toLowerCase() + prop.slice(6);\n    }\n    return style[GuideLabelStyle][styleProp];\n  }\n\n  return null;\n}\n\nfunction keys(objects) {\n  const map = {};\n  for (const obj of objects) {\n    if (!obj) continue;\n    for (const key in obj) map[key] = 1;\n  }\n  return Object.keys(map);\n}\n\nexport default function(spec, scope) {\n  var config = scope.config,\n      style = config.style,\n      axis = config.axis,\n      band = scope.scaleType(spec.scale) === 'band' && config.axisBand,\n      orient = spec.orient,\n      xy, or, key;\n\n  if (isSignal(orient)) {\n    const xyKeys = keys([\n            config.axisX, config.axisY\n          ]),\n          orientKeys = keys([\n            config.axisTop, config.axisBottom,\n            config.axisLeft, config.axisRight\n          ]);\n\n    xy = {};\n    for (key of xyKeys) {\n      xy[key] = ifX(\n        orient,\n        fallback(key, config.axisX, axis, style),\n        fallback(key, config.axisY, axis, style)\n      );\n    }\n\n    or = {};\n    for (key of orientKeys) {\n      or[key] = ifOrient(\n        orient.signal,\n        fallback(key, config.axisTop, axis, style),\n        fallback(key, config.axisBottom, axis, style),\n        fallback(key, config.axisLeft, axis, style),\n        fallback(key, config.axisRight, axis, style)\n      );\n    }\n  } else {\n    xy = (orient === Top || orient === Bottom) ? config.axisX : config.axisY;\n    or = config['axis' + orient[0].toUpperCase() + orient.slice(1)];\n  }\n\n  const result = (xy || or || band)\n    ? extend({}, axis, xy, or, band)\n    : axis;\n\n  return result;\n}\n","import {ifX, ifY} from './axis-util';\nimport {one, zero} from './constants';\nimport guideMark from './guide-mark';\nimport {lookup} from './guide-util';\nimport {addEncoders} from '../encode/util';\nimport {RuleMark} from '../marks/marktypes';\nimport {AxisDomainRole} from '../marks/roles';\n\nexport default function(spec, config, userEncode, dataRef) {\n  const _ = lookup(spec, config),\n        orient = spec.orient;\n\n  let enter, update;\n  const encode = {\n    enter: enter = {opacity: zero},\n    update: update = {opacity: one},\n    exit: {opacity: zero}\n  };\n\n  addEncoders(encode, {\n    stroke:           _('domainColor'),\n    strokeCap:        _('domainCap'),\n    strokeDash:       _('domainDash'),\n    strokeDashOffset: _('domainDashOffset'),\n    strokeWidth:      _('domainWidth'),\n    strokeOpacity:    _('domainOpacity')\n  });\n\n  const pos0 = position(spec, 0);\n  const pos1 = position(spec, 1);\n\n  enter.x = update.x = ifX(orient, pos0, zero);\n  enter.x2 = update.x2 = ifX(orient, pos1);\n\n  enter.y = update.y = ifY(orient, pos0, zero);\n  enter.y2 = update.y2 = ifY(orient, pos1);\n\n  return guideMark({\n    type: RuleMark,\n    role: AxisDomainRole,\n    from: dataRef,\n    encode\n  }, userEncode);\n}\n\nfunction position(spec, pos) {\n  return {scale: spec.scale, range: pos};\n}\n","import {getSign, ifX, ifY} from './axis-util';\nimport {Value, one, zero} from './constants';\nimport guideMark from './guide-mark';\nimport {lookup} from './guide-util';\nimport {addEncoders} from '../encode/util';\nimport {RuleMark} from '../marks/marktypes';\nimport {AxisGridRole} from '../marks/roles';\nimport {isSignal} from '../../util';\nimport {extend, isObject} from 'vega-util';\n\nexport default function(spec, config, userEncode, dataRef, band) {\n  const _ = lookup(spec, config),\n        orient = spec.orient,\n        vscale = spec.gridScale,\n        sign = getSign(orient, 1, -1),\n        offset = offsetValue(spec.offset, sign);\n\n  let enter, exit, update;\n  const encode = {\n    enter: enter = {opacity: zero},\n    update: update = {opacity: one},\n    exit: exit = {opacity: zero}\n  };\n\n  addEncoders(encode, {\n    stroke:           _('gridColor'),\n    strokeCap:        _('gridCap'),\n    strokeDash:       _('gridDash'),\n    strokeDashOffset: _('gridDashOffset'),\n    strokeOpacity:    _('gridOpacity'),\n    strokeWidth:      _('gridWidth')\n  });\n\n  const tickPos = {\n    scale:  spec.scale,\n    field:  Value,\n    band:   band.band,\n    extra:  band.extra,\n    offset: band.offset,\n    round:  _('tickRound')\n  };\n\n  const sz = ifX(orient, {signal: 'height'}, {signal: 'width'});\n\n  const gridStart = vscale\n    ? {scale: vscale, range: 0, mult: sign, offset: offset}\n    : {value: 0, offset: offset};\n\n  const gridEnd = vscale\n    ? {scale: vscale, range: 1, mult: sign, offset: offset}\n    : extend(sz, {mult: sign, offset: offset});\n\n  enter.x = update.x = ifX(orient, tickPos, gridStart);\n  enter.y = update.y = ifY(orient, tickPos, gridStart);\n  enter.x2 = update.x2 = ifY(orient, gridEnd);\n  enter.y2 = update.y2 = ifX(orient, gridEnd);\n  exit.x = ifX(orient, tickPos);\n  exit.y = ifY(orient, tickPos);\n\n  return guideMark({\n    type: RuleMark,\n    role: AxisGridRole,\n    key:  Value,\n    from: dataRef,\n    encode\n   }, userEncode);\n}\n\nfunction offsetValue(offset, sign)  {\n  if (sign === 1) {\n    // no further adjustment needed, just return offset\n  } else if (!isObject(offset)) {\n    offset = isSignal(sign)\n      ? {signal: `(${sign.signal}) * (${offset || 0})`}\n      : sign * (offset || 0);\n  } else {\n    let entry = offset = extend({}, offset);\n    while (entry.mult != null) {\n      if (!isObject(entry.mult)) {\n        entry.mult = isSignal(sign) // no offset if sign === 1\n          ? {signal: `(${entry.mult}) * (${sign.signal})`}\n          : entry.mult * sign;\n        return offset;\n      } else {\n        entry = entry.mult = extend({}, entry.mult);\n      }\n    }\n    entry.mult = sign;\n  }\n\n  return offset;\n}\n","import {getSign, ifRight, ifTop, ifX, ifY, patch} from './axis-util';\nimport {GuideLabelStyle, Label, Value, one, zero} from './constants';\nimport guideMark from './guide-mark';\nimport {extendOffset, lookup} from './guide-util';\nimport {addEncoders, encoder} from '../encode/util';\nimport {TextMark} from '../marks/marktypes';\nimport {AxisLabelRole} from '../marks/roles';\nimport {deref} from '../../util';\n\nfunction flushExpr(scale, threshold, a, b, c) {\n  return {\n    signal: 'flush(range(\"' + scale + '\"), '\n      + 'scale(\"' + scale + '\", datum.value), '\n      + threshold + ',' + a + ',' + b + ',' + c + ')'\n  };\n}\n\nexport default function(spec, config, userEncode, dataRef, size, band) {\n  const _ = lookup(spec, config),\n        orient = spec.orient,\n        scale = spec.scale,\n        sign = getSign(orient, -1, 1),\n        flush = deref(_('labelFlush')),\n        flushOffset = deref(_('labelFlushOffset')),\n        labelAlign = _('labelAlign'),\n        labelBaseline = _('labelBaseline');\n\n  let flushOn = flush === 0 || !!flush,\n      update;\n\n  const tickSize = encoder(size);\n  tickSize.mult = sign;\n  tickSize.offset = encoder(_('labelPadding') || 0);\n  tickSize.offset.mult = sign;\n\n  const tickPos = {\n    scale:  scale,\n    field:  Value,\n    band:   0.5,\n    offset: extendOffset(band.offset, _('labelOffset'))\n  };\n\n  const align = ifX(orient,\n    flushOn\n      ? flushExpr(scale, flush, '\"left\"', '\"right\"', '\"center\"')\n      : {value: 'center'},\n    ifRight(orient, 'left', 'right')\n  );\n\n  const baseline = ifX(orient,\n    ifTop(orient, 'bottom', 'top'),\n    flushOn\n      ? flushExpr(scale, flush, '\"top\"', '\"bottom\"', '\"middle\"')\n      : {value: 'middle'}\n  );\n\n  const offsetExpr = flushExpr(scale, flush, `-(${flushOffset})`, flushOffset, 0);\n  flushOn = flushOn && flushOffset;\n\n  const enter = {\n    opacity: zero,\n    x: ifX(orient, tickPos, tickSize),\n    y: ifY(orient, tickPos, tickSize)\n  };\n\n  const encode = {\n    enter: enter,\n    update: update = {\n      opacity: one,\n      text: {field: Label},\n      x: enter.x,\n      y: enter.y,\n      align,\n      baseline\n    },\n    exit: {\n      opacity: zero,\n      x: enter.x,\n      y: enter.y\n    }\n  };\n\n  addEncoders(encode, {\n    dx: !labelAlign && flushOn ? ifX(orient, offsetExpr) : null,\n    dy: !labelBaseline && flushOn ? ifY(orient, offsetExpr) : null\n  });\n\n  addEncoders(encode, {\n    angle:       _('labelAngle'),\n    fill:        _('labelColor'),\n    fillOpacity: _('labelOpacity'),\n    font:        _('labelFont'),\n    fontSize:    _('labelFontSize'),\n    fontWeight:  _('labelFontWeight'),\n    fontStyle:   _('labelFontStyle'),\n    limit:       _('labelLimit'),\n    lineHeight:  _('labelLineHeight')\n  }, {\n    align:       labelAlign,\n    baseline:    labelBaseline\n  });\n\n  const bound   = _('labelBound');\n  let overlap = _('labelOverlap');\n\n  // if overlap method or bound defined, request label overlap removal\n  overlap = overlap || bound ? {\n    separation: _('labelSeparation'),\n    method: overlap,\n    order: 'datum.index',\n    bound: bound ? {scale, orient, tolerance: bound} : null\n  } : undefined;\n\n  if (update.align !== align) {\n    update.align = patch(update.align, align);\n  }\n  if (update.baseline !== baseline) {\n    update.baseline = patch(update.baseline, baseline);\n  }\n\n  return guideMark({\n    type:  TextMark,\n    role:  AxisLabelRole,\n    style: GuideLabelStyle,\n    key:   Value,\n    from:  dataRef,\n    encode,\n    overlap\n  }, userEncode);\n}\n","import {getSign, ifTop, ifX, ifY, mult, patch} from './axis-util';\nimport {Bottom, GuideTitleStyle, Top, one, zero} from './constants';\nimport guideMark from './guide-mark';\nimport {alignExpr, anchorExpr, lookup} from './guide-util';\nimport {addEncoders, encoder, has} from '../encode/util';\nimport {TextMark} from '../marks/marktypes';\nimport {AxisTitleRole} from '../marks/roles';\nimport {extend} from 'vega-util';\n\nexport default function(spec, config, userEncode, dataRef) {\n  const _ = lookup(spec, config),\n        orient = spec.orient,\n        sign = getSign(orient, -1, 1);\n\n  let enter, update;\n  const encode = {\n    enter: enter = {\n      opacity: zero,\n      anchor: encoder(_('titleAnchor', null)),\n      align: {signal: alignExpr}\n    },\n    update: update = extend({}, enter, {\n      opacity: one,\n      text: encoder(spec.title)\n    }),\n    exit: {\n      opacity: zero\n    }\n  };\n\n  const titlePos = {\n    signal: `lerp(range(\"${spec.scale}\"), ${anchorExpr(0, 1, 0.5)})`\n  };\n\n  update.x = ifX(orient, titlePos);\n  update.y = ifY(orient, titlePos);\n  enter.angle = ifX(orient, zero, mult(sign, 90));\n  enter.baseline = ifX(orient, ifTop(orient, Bottom, Top), {value: Bottom});\n  update.angle = enter.angle;\n  update.baseline = enter.baseline;\n\n  addEncoders(encode, {\n    fill:        _('titleColor'),\n    fillOpacity: _('titleOpacity'),\n    font:        _('titleFont'),\n    fontSize:    _('titleFontSize'),\n    fontStyle:   _('titleFontStyle'),\n    fontWeight:  _('titleFontWeight'),\n    limit:       _('titleLimit'),\n    lineHeight:  _('titleLineHeight')\n  }, { // require update\n    align:       _('titleAlign'),\n    angle:       _('titleAngle'),\n    baseline:    _('titleBaseline')\n  });\n\n  autoLayout(_, orient, encode, userEncode);\n  encode.update.align = patch(encode.update.align, enter.align);\n  encode.update.angle = patch(encode.update.angle, enter.angle);\n  encode.update.baseline = patch(encode.update.baseline, enter.baseline);\n\n  return guideMark({\n    type:  TextMark,\n    role:  AxisTitleRole,\n    style: GuideTitleStyle,\n    from:  dataRef,\n    encode\n  }, userEncode);\n}\n\nfunction autoLayout(_, orient, encode, userEncode) {\n  const auto = (value, dim) => value != null\n    ? (encode.update[dim] = patch(encoder(value), encode.update[dim]), false)\n    : !has(dim, userEncode) ? true : false;\n\n  const autoY = auto(_('titleX'), 'x'),\n        autoX = auto(_('titleY'), 'y');\n\n  encode.enter.auto = autoX === autoY\n    ? encoder(autoX)\n    : ifX(orient, encoder(autoX), encoder(autoY));\n}\n","import {addEncoders, extendEncode} from './encode/util';\nimport axisConfig from './guides/axis-config';\nimport axisDomain from './guides/axis-domain';\nimport axisGrid from './guides/axis-grid';\nimport axisTicks from './guides/axis-ticks';\nimport axisLabels from './guides/axis-labels';\nimport axisTitle from './guides/axis-title';\nimport {Skip} from './guides/constants';\nimport guideGroup from './guides/guide-group';\nimport {lookup, tickBand} from './guides/guide-util';\nimport {AxisRole} from './marks/roles';\nimport parseMark from './mark';\nimport {AxisTicks, Collect} from '../transforms';\nimport {ref, value} from '../util';\n\nexport default function(spec, scope) {\n  const config = axisConfig(spec, scope),\n        encode = spec.encode || {},\n        axisEncode = encode.axis || {},\n        name = axisEncode.name || undefined,\n        interactive = axisEncode.interactive,\n        style = axisEncode.style,\n        _ = lookup(spec, config),\n        band = tickBand(_);\n\n  // single-element data source for axis group\n  const datum = {\n    scale:  spec.scale,\n    ticks:  !!_('ticks'),\n    labels: !!_('labels'),\n    grid:   !!_('grid'),\n    domain: !!_('domain'),\n    title:  spec.title != null\n  };\n  const dataRef = ref(scope.add(Collect({}, [datum])));\n\n  // data source for axis ticks\n  const ticksRef = ref(scope.add(AxisTicks({\n    scale:   scope.scaleRef(spec.scale),\n    extra:   scope.property(band.extra),\n    count:   scope.objectProperty(spec.tickCount),\n    values:  scope.objectProperty(spec.values),\n    minstep: scope.property(spec.tickMinStep),\n    formatType: scope.property(spec.formatType),\n    formatSpecifier: scope.property(spec.format)\n  })));\n\n  // generate axis marks\n  const children = [];\n  let size;\n\n  // include axis gridlines if requested\n  if (datum.grid) {\n    children.push(axisGrid(spec, config, encode.grid, ticksRef, band));\n  }\n\n  // include axis ticks if requested\n  if (datum.ticks) {\n    size = _('tickSize');\n    children.push(axisTicks(spec, config, encode.ticks, ticksRef, size, band));\n  }\n\n  // include axis labels if requested\n  if (datum.labels) {\n    size = datum.ticks ? size : 0;\n    children.push(axisLabels(spec, config, encode.labels, ticksRef, size, band));\n  }\n\n  // include axis domain path if requested\n  if (datum.domain) {\n    children.push(axisDomain(spec, config, encode.domain, dataRef));\n  }\n\n  // include axis title if defined\n  if (datum.title) {\n    children.push(axisTitle(spec, config, encode.title, dataRef));\n  }\n\n  // parse axis specification\n  return parseMark(\n    guideGroup({\n      role:        AxisRole,\n      from:        dataRef,\n      encode:      extendEncode(buildAxisEncode(_, spec), axisEncode, Skip),\n      marks:       children,\n      aria:        _('aria'),\n      description: _('description'),\n      zindex:      _('zindex'),\n      name,\n      interactive,\n      style\n    }),\n    scope\n  );\n}\n\nfunction buildAxisEncode(_, spec) {\n  const encode = {enter: {}, update: {}};\n\n  addEncoders(encode, {\n    orient:       _('orient'),\n    offset:       _('offset') || 0,\n    position:     value(spec.position, 0),\n    titlePadding: _('titlePadding'),\n    minExtent:    _('minExtent'),\n    maxExtent:    _('maxExtent'),\n    range:        {signal: `abs(span(range(\"${spec.scale}\")))`},\n    translate:    _('translate'),\n\n    // accessibility support\n    format:       spec.format,\n    formatType:   spec.formatType\n  });\n\n  return encode;\n}\n","import {getSign, ifX, ifY} from './axis-util';\nimport {Value, one, zero} from './constants';\nimport guideMark from './guide-mark';\nimport {lookup} from './guide-util';\nimport {addEncoders, encoder} from '../encode/util';\nimport {RuleMark} from '../marks/marktypes';\nimport {AxisTickRole} from '../marks/roles';\n\nexport default function(spec, config, userEncode, dataRef, size, band) {\n  const _ = lookup(spec, config),\n        orient = spec.orient,\n        sign = getSign(orient, -1, 1);\n\n  let enter, exit, update;\n  const encode = {\n    enter: enter = {opacity: zero},\n    update: update = {opacity: one},\n    exit: exit = {opacity: zero}\n  };\n\n  addEncoders(encode, {\n    stroke:           _('tickColor'),\n    strokeCap:        _('tickCap'),\n    strokeDash:       _('tickDash'),\n    strokeDashOffset: _('tickDashOffset'),\n    strokeOpacity:    _('tickOpacity'),\n    strokeWidth:      _('tickWidth')\n  });\n\n  const tickSize = encoder(size);\n  tickSize.mult = sign;\n\n  const tickPos = {\n    scale:  spec.scale,\n    field:  Value,\n    band:   band.band,\n    extra:  band.extra,\n    offset: band.offset,\n    round:  _('tickRound')\n  };\n\n  update.y = enter.y = ifX(orient, zero, tickPos);\n  update.y2 = enter.y2 = ifX(orient, tickSize);\n  exit.x = ifX(orient, tickPos);\n\n  update.x = enter.x = ifY(orient, zero, tickPos);\n  update.x2 = enter.x2 = ifY(orient, tickSize);\n  exit.y = ifY(orient, tickPos);\n\n  return guideMark({\n    type: RuleMark,\n    role: AxisTickRole,\n    key:  Value,\n    from: dataRef,\n    encode\n  }, userEncode);\n}\n","import parseSignalUpdates from './signal-updates';\nimport {initScale, parseScale} from './scale';\nimport parseProjection from './projection';\nimport parseLegend from './legend';\nimport parseSignal from './signal';\nimport parseTitle from './title';\nimport parseData from './data';\nimport parseMark from './mark';\nimport parseAxis from './axis';\nimport {array} from 'vega-util';\n\nexport default function(spec, scope, preprocessed) {\n  const signals = array(spec.signals),\n        scales = array(spec.scales);\n\n  // parse signal definitions, if not already preprocessed\n  if (!preprocessed) signals.forEach(_ => parseSignal(_, scope));\n\n  // parse cartographic projection definitions\n  array(spec.projections).forEach(_ => parseProjection(_, scope));\n\n  // initialize scale references\n  scales.forEach(_ => initScale(_, scope));\n\n  // parse data sources\n  array(spec.data).forEach(_ => parseData(_, scope));\n\n  // parse scale definitions\n  scales.forEach(_ => parseScale(_, scope));\n\n  // parse signal updates\n  (preprocessed || signals).forEach(_ => parseSignalUpdates(_, scope));\n\n  // parse axis definitions\n  array(spec.axes).forEach(_ => parseAxis(_, scope));\n\n  // parse mark definitions\n  array(spec.marks).forEach(_ => parseMark(_, scope));\n\n  // parse legend definitions\n  array(spec.legends).forEach(_ => parseLegend(_, scope));\n\n  // parse title, if defined\n  if (spec.title) parseTitle(spec.title, scope);\n\n  // parse collected lambda (anonymous) expressions\n  scope.parseLambdas();\n\n  return scope;\n}\n","import parseAutosize from './autosize';\nimport parsePadding from './padding';\nimport parseEncode from './encode';\nimport parseSignal from './signal';\nimport parseSpec from './scope';\nimport {extendEncode} from './encode/util';\nimport {GroupMark} from './marks/marktypes';\nimport {FrameRole} from './marks/roles';\nimport {operator, ref, value} from '../util';\nimport DataScope from '../DataScope';\nimport {Bound, Collect, Encode, Render, Sieve, ViewLayout} from '../transforms';\nimport {array, extend, hasOwnProperty} from 'vega-util';\n\nconst rootEncode = spec => extendEncode(\n  {\n    enter: {\n      x: {value: 0},\n      y: {value: 0}\n    },\n    update: {\n      width: {signal: 'width'},\n      height: {signal: 'height'}\n    }\n  },\n  spec\n);\n\nexport default function parseView(spec, scope) {\n  const config = scope.config;\n\n  // add scenegraph root\n  const root = ref(scope.root = scope.add(operator()));\n\n  // parse top-level signal definitions\n  const signals = collectSignals(spec, config);\n  signals.forEach(_ => parseSignal(_, scope));\n\n  // assign description, event, legend, and locale configuration\n  scope.description = spec.description || config.description;\n  scope.eventConfig = config.events;\n  scope.legends = scope.objectProperty(config.legend && config.legend.layout);\n  scope.locale = config.locale;\n\n  // store root group item\n  const input = scope.add(Collect());\n\n  // encode root group item\n  const encode = scope.add(Encode(parseEncode(\n    rootEncode(spec.encode), GroupMark, FrameRole,\n    spec.style, scope, {pulse: ref(input)}\n  )));\n\n  // perform view layout\n  const parent = scope.add(ViewLayout({\n    layout:   scope.objectProperty(spec.layout),\n    legends:  scope.legends,\n    autosize: scope.signalRef('autosize'),\n    mark:     root,\n    pulse:    ref(encode)\n  }));\n  scope.operators.pop();\n\n  // parse remainder of specification\n  scope.pushState(ref(encode), ref(parent), null);\n  parseSpec(spec, scope, signals);\n  scope.operators.push(parent);\n\n  // bound / render / sieve root item\n  let op = scope.add(Bound({mark: root, pulse: ref(parent)}));\n  op = scope.add(Render({pulse: ref(op)}));\n  op = scope.add(Sieve({pulse: ref(op)}));\n\n  // track metadata for root item\n  scope.addData('root', new DataScope(scope, input, input, op));\n\n  return scope;\n}\n\nfunction signalObject(name, value) {\n  return value && value.signal\n    ? { name, update: value.signal }\n    : { name, value };\n}\n\n/**\n * Collect top-level signals, merging values as needed. Signals\n * defined in the config signals arrays are added only if that\n * signal is not explicitly defined in the specification.\n * Built-in signals (autosize, background, padding, width, height)\n * receive special treatment. They are initialized using the\n * top-level spec property, or, if undefined in the spec, using\n * the corresponding top-level config property. If this property\n * is a signal reference object, the signal expression maps to the\n * signal 'update' property. If the spec's top-level signal array\n * contains an entry that matches a built-in signal, that entry\n * will be merged with the built-in specification, potentially\n * overwriting existing 'value' or 'update' properties.\n */\nfunction collectSignals(spec, config) {\n  const _ = name => value(spec[name], config[name]),\n        signals = [\n          signalObject('background', _('background')),\n          signalObject('autosize', parseAutosize(_('autosize'))),\n          signalObject('padding', parsePadding(_('padding'))),\n          signalObject('width', _('width') || 0),\n          signalObject('height', _('height') || 0)\n        ],\n        pre = signals.reduce((p, s) => (p[s.name] = s, p), {}),\n        map = {};\n\n  // add spec signal array\n  array(spec.signals).forEach(s => {\n    if (hasOwnProperty(pre, s.name)) {\n      // merge if built-in signal\n      s = extend(pre[s.name], s);\n    } else {\n      // otherwise add to signal list\n      signals.push(s);\n    }\n    map[s.name] = s;\n  });\n\n  // add config signal array\n  array(config.signals).forEach(s => {\n    if (!hasOwnProperty(map, s.name) && !hasOwnProperty(pre, s.name)) {\n      // add to signal list if not already defined\n      signals.push(s);\n    }\n  });\n\n  return signals;\n}\n","import DataScope from './DataScope';\n\nimport {\n  Compare, Expression, Field, Key, Projection, Proxy, Scale, Sieve\n} from './transforms';\n\nimport {\n  Ascending, Entry, aggrField, compareRef, fieldRef, isExpr,\n  isSignal, keyRef, operator, ref\n} from './util';\n\nimport parseScope from './parsers/scope';\nimport {parseExpression} from 'vega-functions';\n\nimport {\n  array, error, extend, hasOwnProperty,\n  isArray, isObject, isString, peek, stringValue\n} from 'vega-util';\n\nexport default function Scope(config, options) {\n  this.config = config || {};\n  this.options = options || {};\n\n  this.bindings = [];\n  this.field = {};\n  this.signals = {};\n  this.lambdas = {};\n  this.scales = {};\n  this.events = {};\n  this.data = {};\n\n  this.streams = [];\n  this.updates = [];\n  this.operators = [];\n  this.eventConfig = null;\n  this.locale = null;\n\n  this._id = 0;\n  this._subid = 0;\n  this._nextsub = [0];\n\n  this._parent = [];\n  this._encode = [];\n  this._lookup = [];\n  this._markpath = [];\n}\n\nfunction Subscope(scope) {\n  this.config = scope.config;\n  this.options = scope.options;\n  this.legends = scope.legends;\n\n  this.field = Object.create(scope.field);\n  this.signals = Object.create(scope.signals);\n  this.lambdas = Object.create(scope.lambdas);\n  this.scales = Object.create(scope.scales);\n  this.events = Object.create(scope.events);\n  this.data = Object.create(scope.data);\n\n  this.streams = [];\n  this.updates = [];\n  this.operators = [];\n\n  this._id = 0;\n  this._subid = ++scope._nextsub[0];\n  this._nextsub = scope._nextsub;\n\n  this._parent = scope._parent.slice();\n  this._encode = scope._encode.slice();\n  this._lookup = scope._lookup.slice();\n  this._markpath = scope._markpath;\n}\n\nScope.prototype = Subscope.prototype = {\n  parse(spec) {\n    return parseScope(spec, this);\n  },\n\n  fork() {\n    return new Subscope(this);\n  },\n\n  isSubscope() {\n    return this._subid > 0;\n  },\n\n  toRuntime() {\n    this.finish();\n    return {\n      description: this.description,\n      operators:   this.operators,\n      streams:     this.streams,\n      updates:     this.updates,\n      bindings:    this.bindings,\n      eventConfig: this.eventConfig,\n      locale:      this.locale\n    };\n  },\n\n  id() {\n    return (this._subid ? this._subid + ':' : 0) + this._id++;\n  },\n\n  add(op) {\n    this.operators.push(op);\n    op.id = this.id();\n    // if pre-registration references exist, resolve them now\n    if (op.refs) {\n      op.refs.forEach(ref => { ref.$ref = op.id; });\n      op.refs = null;\n    }\n    return op;\n  },\n\n  proxy(op) {\n    const vref = op instanceof Entry ? ref(op) : op;\n    return this.add(Proxy({value: vref}));\n  },\n\n  addStream(stream) {\n    this.streams.push(stream);\n    stream.id = this.id();\n    return stream;\n  },\n\n  addUpdate(update) {\n    this.updates.push(update);\n    return update;\n  },\n\n  // Apply metadata\n  finish() {\n    let name, ds;\n\n    // annotate root\n    if (this.root) this.root.root = true;\n\n    // annotate signals\n    for (name in this.signals) {\n      this.signals[name].signal = name;\n    }\n\n    // annotate scales\n    for (name in this.scales) {\n      this.scales[name].scale = name;\n    }\n\n    // annotate data sets\n    function annotate(op, name, type) {\n      let data, list;\n      if (op) {\n        data = op.data || (op.data = {});\n        list = data[name] || (data[name] = []);\n        list.push(type);\n      }\n    }\n    for (name in this.data) {\n      ds = this.data[name];\n      annotate(ds.input,  name, 'input');\n      annotate(ds.output, name, 'output');\n      annotate(ds.values, name, 'values');\n      for (const field in ds.index) {\n        annotate(ds.index[field], name, 'index:' + field);\n      }\n    }\n\n    return this;\n  },\n\n  // ----\n\n  pushState(encode, parent, lookup) {\n    this._encode.push(ref(this.add(Sieve({pulse: encode}))));\n    this._parent.push(parent);\n    this._lookup.push(lookup ? ref(this.proxy(lookup)) : null);\n    this._markpath.push(-1);\n  },\n\n  popState() {\n    this._encode.pop();\n    this._parent.pop();\n    this._lookup.pop();\n    this._markpath.pop();\n  },\n\n  parent() {\n    return peek(this._parent);\n  },\n\n  encode() {\n    return peek(this._encode);\n  },\n\n  lookup() {\n    return peek(this._lookup);\n  },\n\n  markpath() {\n    const p = this._markpath;\n    return ++p[p.length-1];\n  },\n\n  // ----\n\n  fieldRef(field, name) {\n    if (isString(field)) return fieldRef(field, name);\n    if (!field.signal) {\n      error('Unsupported field reference: ' + stringValue(field));\n    }\n\n    const s = field.signal;\n    let f = this.field[s];\n\n    if (!f) {\n      const params = {name: this.signalRef(s)};\n      if (name) params.as = name;\n      this.field[s] = f = ref(this.add(Field(params)));\n    }\n    return f;\n  },\n\n  compareRef(cmp) {\n    let signal = false;\n\n    const check = _ => isSignal(_)\n      ? (signal = true, this.signalRef(_.signal))\n      : isExpr(_) ? (signal = true, this.exprRef(_.expr))\n      : _;\n\n    const fields = array(cmp.field).map(check),\n          orders = array(cmp.order).map(check);\n\n    return signal\n      ? ref(this.add(Compare({fields: fields, orders: orders})))\n      : compareRef(fields, orders);\n  },\n\n  keyRef(fields, flat) {\n    let signal = false;\n\n    const check = _ => isSignal(_)\n      ? (signal = true, ref(sig[_.signal]))\n      : _;\n\n    const sig = this.signals;\n    fields = array(fields).map(check);\n\n    return signal\n      ? ref(this.add(Key({fields: fields, flat: flat})))\n      : keyRef(fields, flat);\n  },\n\n  sortRef(sort) {\n    if (!sort) return sort;\n\n    // including id ensures stable sorting\n    const a = aggrField(sort.op, sort.field),\n         o = sort.order || Ascending;\n\n    return o.signal\n      ? ref(this.add(Compare({\n          fields: a,\n          orders: this.signalRef(o.signal)\n        })))\n      : compareRef(a, o);\n  },\n\n  // ----\n\n  event(source, type) {\n    const key = source + ':' + type;\n    if (!this.events[key]) {\n      const id = this.id();\n      this.streams.push({\n        id: id,\n        source: source,\n        type: type\n      });\n      this.events[key] = id;\n    }\n    return this.events[key];\n  },\n\n  // ----\n\n  hasOwnSignal(name) {\n    return hasOwnProperty(this.signals, name);\n  },\n\n  addSignal(name, value) {\n    if (this.hasOwnSignal(name)) {\n      error('Duplicate signal name: ' + stringValue(name));\n    }\n    const op = value instanceof Entry ? value : this.add(operator(value));\n    return this.signals[name] = op;\n  },\n\n  getSignal(name) {\n    if (!this.signals[name]) {\n      error('Unrecognized signal name: ' + stringValue(name));\n    }\n    return this.signals[name];\n  },\n\n  signalRef(s) {\n    if (this.signals[s]) {\n      return ref(this.signals[s]);\n    } else if (!hasOwnProperty(this.lambdas, s)) {\n      this.lambdas[s] = this.add(operator(null));\n    }\n    return ref(this.lambdas[s]);\n  },\n\n  parseLambdas() {\n    const code = Object.keys(this.lambdas);\n    for (let i=0, n=code.length; i<n; ++i) {\n      const s = code[i],\n            e = parseExpression(s, this),\n            op = this.lambdas[s];\n      op.params = e.$params;\n      op.update = e.$expr;\n    }\n  },\n\n  property(spec) {\n    return spec && spec.signal ? this.signalRef(spec.signal) : spec;\n  },\n\n  objectProperty(spec) {\n    return (!spec || !isObject(spec)) ? spec\n      : this.signalRef(spec.signal || propertyLambda(spec));\n  },\n\n  exprRef(code, name) {\n    const params = {expr: parseExpression(code, this)};\n    if (name) params.expr.$name = name;\n    return ref(this.add(Expression(params)));\n  },\n\n  addBinding(name, bind) {\n    if (!this.bindings) {\n      error('Nested signals do not support binding: ' + stringValue(name));\n    }\n    this.bindings.push(extend({signal: name}, bind));\n  },\n\n  // ----\n\n  addScaleProj(name, transform) {\n    if (hasOwnProperty(this.scales, name)) {\n      error('Duplicate scale or projection name: ' + stringValue(name));\n    }\n    this.scales[name] = this.add(transform);\n  },\n\n  addScale(name, params) {\n    this.addScaleProj(name, Scale(params));\n  },\n\n  addProjection(name, params) {\n    this.addScaleProj(name, Projection(params));\n  },\n\n  getScale(name) {\n    if (!this.scales[name]) {\n      error('Unrecognized scale name: ' + stringValue(name));\n    }\n    return this.scales[name];\n  },\n\n  scaleRef(name) {\n    return ref(this.getScale(name));\n  },\n\n  scaleType(name) {\n    return this.getScale(name).params.type;\n  },\n\n  projectionRef(name) {\n    return this.scaleRef(name);\n  },\n\n  projectionType(name) {\n    return this.scaleType(name);\n  },\n\n  // ----\n\n  addData(name, dataScope) {\n    if (hasOwnProperty(this.data, name)) {\n      error('Duplicate data set name: ' + stringValue(name));\n    }\n    return (this.data[name] = dataScope);\n  },\n\n  getData(name) {\n    if (!this.data[name]) {\n      error('Undefined data set name: ' + stringValue(name));\n    }\n    return this.data[name];\n  },\n\n  addDataPipeline(name, entries) {\n    if (hasOwnProperty(this.data, name)) {\n      error('Duplicate data set name: ' + stringValue(name));\n    }\n    return this.addData(name, DataScope.fromEntries(this, entries));\n  }\n};\n\nfunction propertyLambda(spec) {\n  return (isArray(spec) ? arrayLambda : objectLambda)(spec);\n}\n\nfunction arrayLambda(array) {\n  const n = array.length;\n  let code = '[';\n\n  for (let i = 0; i<n; ++i) {\n    const value = array[i];\n    code += (i > 0 ? ',' : '')\n      + (isObject(value)\n        ? (value.signal || propertyLambda(value))\n        : stringValue(value));\n  }\n  return code + ']';\n}\n\nfunction objectLambda(obj) {\n  let code = '{',\n      i = 0,\n      key, value;\n\n  for (key in obj) {\n    value = obj[key];\n    code += (++i > 1 ? ',' : '')\n      + stringValue(key) + ':'\n      + (isObject(value)\n        ? (value.signal || propertyLambda(value))\n        : stringValue(value));\n  }\n  return code + '}';\n}\n","/**\n * Standard configuration defaults for Vega specification parsing.\n * Users can provide their own (sub-)set of these default values\n * by passing in a config object to the top-level parse method.\n */\nexport default function() {\n  const defaultFont = 'sans-serif',\n        defaultSymbolSize = 30,\n        defaultStrokeWidth = 2,\n        defaultColor = '#4c78a8',\n        black = '#000',\n        gray = '#888',\n        lightGray = '#ddd';\n\n  return {\n    // default visualization description\n    description: 'Vega visualization',\n\n    // default padding around visualization\n    padding: 0,\n\n    // default for automatic sizing; options: 'none', 'pad', 'fit'\n    // or provide an object (e.g., {'type': 'pad', 'resize': true})\n    autosize: 'pad',\n\n    // default view background color\n    // covers the entire view component\n    background: null,\n\n    // default event handling configuration\n    // preventDefault for view-sourced event types except 'wheel'\n    events: {\n      defaults: {allow: ['wheel']}\n    },\n\n    // defaults for top-level group marks\n    // accepts mark properties (fill, stroke, etc)\n    // covers the data rectangle within group width/height\n    group: null,\n\n    // defaults for basic mark types\n    // each subset accepts mark properties (fill, stroke, etc)\n    mark: null,\n    arc: {\n      fill: defaultColor\n    },\n    area: {\n      fill: defaultColor\n    },\n    image: null,\n    line: {\n      stroke: defaultColor,\n      strokeWidth: defaultStrokeWidth\n    },\n    path: {\n      stroke: defaultColor\n    },\n    rect: {\n      fill: defaultColor\n    },\n    rule: {\n      stroke: black\n    },\n    shape: {\n      stroke: defaultColor\n    },\n    symbol: {\n      fill: defaultColor,\n      size: 64\n    },\n    text: {\n      fill: black,\n      font: defaultFont,\n      fontSize: 11\n    },\n    trail: {\n      fill: defaultColor,\n      size: defaultStrokeWidth\n    },\n\n    // style definitions\n    style: {\n      // axis & legend labels\n      'guide-label': {\n        fill: black,\n        font: defaultFont,\n        fontSize: 10\n      },\n      // axis & legend titles\n      'guide-title': {\n        fill: black,\n        font: defaultFont,\n        fontSize: 11,\n        fontWeight: 'bold'\n      },\n      // headers, including chart title\n      'group-title': {\n        fill: black,\n        font: defaultFont,\n        fontSize: 13,\n        fontWeight: 'bold'\n      },\n      // chart subtitle\n      'group-subtitle': {\n        fill: black,\n        font: defaultFont,\n        fontSize: 12\n      },\n      // defaults for styled point marks in Vega-Lite\n      point: {\n        size: defaultSymbolSize,\n        strokeWidth: defaultStrokeWidth,\n        shape: 'circle'\n      },\n      circle: {\n        size: defaultSymbolSize,\n        strokeWidth: defaultStrokeWidth\n      },\n      square: {\n        size: defaultSymbolSize,\n        strokeWidth: defaultStrokeWidth,\n        shape: 'square'\n      },\n      // defaults for styled group marks in Vega-Lite\n      cell: {\n        fill: 'transparent',\n        stroke: lightGray\n      }\n    },\n\n    // defaults for title\n    title: {\n      orient: 'top',\n      anchor: 'middle',\n      offset: 4,\n      subtitlePadding: 3\n    },\n\n    // defaults for axes\n    axis: {\n      minExtent: 0,\n      maxExtent: 200,\n      bandPosition: 0.5,\n      domain: true,\n      domainWidth: 1,\n      domainColor: gray,\n      grid: false,\n      gridWidth: 1,\n      gridColor: lightGray,\n      labels: true,\n      labelAngle: 0,\n      labelLimit: 180,\n      labelOffset: 0,\n      labelPadding: 2,\n      ticks: true,\n      tickColor: gray,\n      tickOffset: 0,\n      tickRound: true,\n      tickSize: 5,\n      tickWidth: 1,\n      titlePadding: 4\n    },\n\n    // correction for centering bias\n    axisBand: {\n      tickOffset: -0.5\n    },\n\n    // defaults for cartographic projection\n    projection: {\n      type: 'mercator'\n    },\n\n    // defaults for legends\n    legend: {\n      orient: 'right',\n      padding: 0,\n      gridAlign: 'each',\n      columnPadding: 10,\n      rowPadding: 2,\n      symbolDirection: 'vertical',\n      gradientDirection: 'vertical',\n      gradientLength: 200,\n      gradientThickness: 16,\n      gradientStrokeColor: lightGray,\n      gradientStrokeWidth: 0,\n      gradientLabelOffset: 2,\n      labelAlign: 'left',\n      labelBaseline: 'middle',\n      labelLimit: 160,\n      labelOffset: 4,\n      labelOverlap: true,\n      symbolLimit: 30,\n      symbolType: 'circle',\n      symbolSize: 100,\n      symbolOffset: 0,\n      symbolStrokeWidth: 1.5,\n      symbolBaseFillColor: 'transparent',\n      symbolBaseStrokeColor: gray,\n      titleLimit: 180,\n      titleOrient: 'top',\n      titlePadding: 5,\n      layout: {\n        offset: 18,\n        direction: 'horizontal',\n        left:   { direction: 'vertical' },\n        right:  { direction: 'vertical' }\n      }\n    },\n\n    // defaults for scale ranges\n    range: {\n      category: {\n        scheme: 'tableau10'\n      },\n      ordinal: {\n        scheme: 'blues'\n      },\n      heatmap: {\n        scheme: 'yellowgreenblue'\n      },\n      ramp: {\n        scheme: 'blues'\n      },\n      diverging: {\n        scheme: 'blueorange',\n        extent: [1, 0]\n      },\n      symbol: [\n        'circle',\n        'square',\n        'triangle-up',\n        'cross',\n        'diamond',\n        'triangle-right',\n        'triangle-down',\n        'triangle-left'\n      ]\n    }\n  };\n}\n","import parseView from './parsers/view';\nimport Scope from './Scope';\nimport defaults from './config';\nimport {error, isObject, mergeConfig} from 'vega-util';\n\nexport default function(spec, config, options) {\n  if (!isObject(spec)) {\n    error('Input Vega specification must be an object.');\n  }\n\n  config = mergeConfig(defaults(), config, spec.config);\n  return parseView(spec, new Scope(config, options)).toRuntime();\n}\n"],"names":["spec","isObject","type","number","_","signal","top","bottom","left","right","encoder","isArray","extend","value","addEncode","object","name","set","length","update","addEncoders","enter","extendEncode","encode","extra","skip","hasOwnProperty","has","key","MarkRole","FrameRole","ScopeRole","AxisRole","AxisDomainRole","AxisGridRole","AxisLabelRole","AxisTickRole","AxisTitleRole","LegendRole","LegendEntryRole","LegendLabelRole","LegendSymbolRole","LegendTitleRole","TitleTextRole","TitleSubtitleRole","applyDefault","defaults","scaleRef","scale","isString","stringValue","field","entry","enc","gradient","args","start","stop","count","map","peek","pop","unshift","join","color","c","_color","h","l","s","a","b","r","g","undefined","range","band","property","exponent","mult","offset","round","x","y","z","ref","resolveField","datum","level","group","parent","Math","max","error","splitAccessPath","role","style","scope","params","encoders","$encode","config","props","String","startsWith","mark","array","forEach","applyDefaults","parseBlock","block","marktype","channels","fields","parse","code","rule","test","$expr","$fields","Object","keys","$output","expr","parseExpression","$params","OUTER_INVALID","outerError","prefix","push","signals","prop","op","addSignal","react","bind","addBinding","Entry","id","this","operator","$ref","refs","fieldRef","$field","$name","keyFieldRef","compareRef","orders","$compare","$order","aggrField","Scope","View","isSignal","hasSignal","specValue","defaultValue","deref","v","Timer","parseStream","stream","merge","mergeStream","nestedStream","eventStream","streamParameters","addStream","source","event","throttle","between","filter","param","concat","markname","markrole","item","filterMark","debounce","consume","OP_VALUE_EXPR","ast","target","events","sources","parseSelector","isSubscope","mergeSources","$value","signalRef","force","options","addUpdate","streamSource","getSignal","init","initonly","on","parseUpdate","transform","Aggregate","AxisTicks","Bound","Collect","Compare","DataJoin","Encode","Expression","Facet","Field","Key","LegendEntries","Load","Mark","MultiExtent","MultiValues","Overlap","Params","PreFacet","Projection","Proxy","Relay","Render","Scale","Sieve","SortItems","ViewLayout","Values","FIELD_REF_ID","MULTIDOMAIN_SORT_OPS","min","parseScale","getScale","nice","domain","parseScaleDomain","parseScaleRange","interpolate","parseLiteral","gamma","interpolateGamma","parseScaleInterpolate","interval","step","bins","parseArray","objectProperty","parseScaleBins","dataLookupError","explicitDomain","multipleDomain","singularDomain","domainMin","domainMax","data","getData","isDiscrete","valuesRef","parseSort","sort","isQuantile","domainRef","extentRef","reduce","dom","d","coll","$ingest","input","addDataPipeline","ordinalMultipleDomain","quantileMultipleDomain","numericMultipleDomain","counts","f","countsRef","p","groupby","pulse","ops","as","add","sortRef","multidomain","values","extents","scheme","extent","schemeExtent","schemeCount","rangeStep","parseParameter","Top","Left","Right","Bottom","Center","Index","Label","Perc","Value","GuideLabelStyle","GuideTitleStyle","GroupTitleStyle","GroupSubtitleStyle","Symbols","Gradient","Discrete","Size","LegendScales","Skip","interactive","zero","one","GroupMark","RectMark","RuleMark","TextMark","lookup","dflt","isVertical","direction","symbolDirection","gradientDirection","gradientLength","gradientWidth","gradientThickness","gradientHeight","entryColumns","columns","getEncoding","anchorExpr","e","m","alignExpr","extendOffset","assign","extras","userEncode","vertical","thickness","width","height","opacity","fill","exit","stroke","strokeWidth","guideMark","dataRef","u","uu","vv","adjust","from","overlap","text","fillOpacity","font","fontSize","fontStyle","fontWeight","limit","labelLimit","gradientLabelLimit","align","baseline","labelOffset","gradientLabelOffset","separation","method","order","entries","symbolOffset","valueRef","xSignal","yEncode","index","ncols","nrows","baseFill","baseStroke","symbolBaseFillColor","symbolBaseStrokeColor","shape","size","strokeDash","strokeDashOffset","symbols","clip","labels","noBound","row","column","guideGroup","facet","marks","isL","isR","isLR","isVG","exprAlign","exprAnchor","exprAngle","exprBaseline","path","sphere","indexOf","zindex","aria","description","def","definition","t","toLowerCase","parseParameters","proxy","metadata","n","i","pdef","lookupRef","parseIndexParameter","parseSubParameter","parseSubParameters","projectionRef","parameterValue","required","isExpr","isField","isCompare","outerExpr","exprRef","outerField","isData","k","getDataRef","output","DataScope","aggr","aggregate","fieldKey","addSortField","cache","ds","optype","sortKey","remove","insert","toggle","modify","trigger","getRole","store","layoutRef","boundRef","layout","nested","parseTransform","keyRef","parseData","clean","joinRef","markdef","context","$context","groups","markpath","markRef","parseEncode","mod","tx","md","generates","changes","nomod","encodeRef","legends","bound","operators","pushState","subscope","fork","addData","subflow","$subflow","toRuntime","parseFacet","parseSubflow","popState","sep","tol","tolerance","boundTolerance","boundScale","boundOrient","orient","parseOverlap","render","sieve","parseTrigger","legend","legendEncode","scales","entryLayout","children","scaleType","scaleCount","isContinuous","isDiscretizing","legendType","title","vgrad","entryRef","minstep","tickMinStep","formatType","formatSpecifier","format","legendGradient","legendGradientLabels","legendGradientDiscrete","center","padding","legendSymbolLayout","legendSymbolGroups","getChannel","getStyle","getFontSize","sizeExpression","_anchor","anchor","angle","lineHeight","legendTitle","parseMark","buildLegendEncode","titlePadding","cornerRadius","fromEntries","prototype","agg","tuplesRef","indataRef","dx","dy","buildTitle","titleEncode","subtitle","buildSubTitle","groupEncode","frame","transforms","upstream","generate","load","collect","$format","url","$request","modifies","derive","splice","analyze","async","isX","getSign","ifLeftTopExpr","ifX","ifXEnc","ifY","ifYEnc","ifTop","ifTopExpr","$orient","ifEnc","ifExpr","ifRightExpr","isSimple","toExpr","patch","base","endsWith","slice","fallback","axisConfig","styleProp","objects","obj","position","pos","vscale","gridScale","sign","offsetValue","strokeCap","strokeOpacity","tickPos","sz","gridStart","gridEnd","x2","y2","flushExpr","threshold","flush","flushOffset","labelAlign","labelBaseline","flushOn","tickSize","ifRight","offsetExpr","titlePos","auto","dim","autoY","autoX","autoLayout","xy","or","axis","axisBand","xyKeys","axisX","axisY","orientKeys","axisTop","axisBottom","axisLeft","axisRight","toUpperCase","axisEncode","tickBand","ticks","grid","ticksRef","tickCount","axisGrid","axisTicks","axisLabels","pos0","pos1","axisDomain","axisTitle","buildAxisEncode","minExtent","maxExtent","translate","preprocessed","parseSignal","projections","proj","projection","addProjection","parseProjection","isValidScaleType","addScale","initScale","parseSignalUpdates","axes","parseAxis","parseLegend","parseTitle","parseLambdas","parseView","root","signalObject","parseAutosize","parsePadding","pre","collectSignals","eventConfig","locale","rootEncode","autosize","parseSpec","bindings","lambdas","streams","updates","_id","_subid","_nextsub","_parent","_encode","_lookup","_markpath","Subscope","create","propertyLambda","arrayLambda","objectLambda","defaultFont","defaultColor","black","gray","lightGray","background","allow","arc","area","image","line","rect","symbol","trail","point","circle","square","cell","subtitlePadding","bandPosition","domainWidth","domainColor","gridWidth","gridColor","labelAngle","labelPadding","tickColor","tickOffset","tickRound","tickWidth","gridAlign","columnPadding","rowPadding","gradientStrokeColor","gradientStrokeWidth","labelOverlap","symbolLimit","symbolType","symbolSize","symbolStrokeWidth","titleLimit","titleOrient","category","ordinal","heatmap","ramp","diverging","parseScope","finish","vref","annotate","list","cmp","check","flat","sig","$key","$flat","o","hasOwnSignal","addScaleProj","projectionType","dataScope","mergeConfig"],"mappings":"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"}