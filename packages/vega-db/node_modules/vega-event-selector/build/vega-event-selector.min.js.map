{"version":3,"file":"vega-event-selector.min.js","sources":["../src/event-selector.js"],"sourcesContent":["const VIEW    = 'view',\n      LBRACK  = '[',\n      RBRACK  = ']',\n      LBRACE  = '{',\n      RBRACE  = '}',\n      COLON   = ':',\n      COMMA   = ',',\n      NAME    = '@',\n      GT      = '>',\n      ILLEGAL = /[[\\]{}]/,\n      DEFAULT_MARKS = {\n        '*': 1,\n        arc: 1,\n        area: 1,\n        group: 1,\n        image: 1,\n        line: 1,\n        path: 1,\n        rect: 1,\n        rule: 1,\n        shape: 1,\n        symbol: 1,\n        text: 1,\n        trail: 1\n      };\n\nlet DEFAULT_SOURCE,\n    MARKS;\n\n/**\n * Parse an event selector string.\n * Returns an array of event stream definitions.\n */\nexport default function(selector, source, marks) {\n  DEFAULT_SOURCE = source || VIEW;\n  MARKS = marks || DEFAULT_MARKS;\n  return parseMerge(selector.trim()).map(parseSelector);\n}\n\nfunction isMarkType(type) {\n  return MARKS[type];\n}\n\nfunction find(s, i, endChar, pushChar, popChar) {\n  const n = s.length;\n  let count = 0, c;\n\n  for (; i < n; ++i) {\n    c = s[i];\n    if (!count && c === endChar) return i;\n    else if (popChar && popChar.indexOf(c) >= 0) --count;\n    else if (pushChar && pushChar.indexOf(c) >= 0) ++count;\n  }\n  return i;\n}\n\nfunction parseMerge(s) {\n  const output = [],\n        n = s.length;\n  let start = 0, i = 0;\n\n  while (i < n) {\n    i = find(s, i, COMMA, LBRACK + LBRACE, RBRACK + RBRACE);\n    output.push(s.substring(start, i).trim());\n    start = ++i;\n  }\n\n  if (output.length === 0) {\n    throw 'Empty event selector: ' + s;\n  }\n  return output;\n}\n\nfunction parseSelector(s) {\n  return s[0] === '['\n    ? parseBetween(s)\n    : parseStream(s);\n}\n\nfunction parseBetween(s) {\n  const n = s.length;\n  let i = 1, b;\n\n  i = find(s, i, RBRACK, LBRACK, RBRACK);\n  if (i === n) {\n    throw 'Empty between selector: ' + s;\n  }\n\n  b = parseMerge(s.substring(1, i));\n  if (b.length !== 2) {\n    throw 'Between selector must have two elements: ' + s;\n  }\n\n  s = s.slice(i + 1).trim();\n  if (s[0] !== GT) {\n    throw 'Expected \\'>\\' after between selector: ' + s;\n  }\n\n  b = b.map(parseSelector);\n\n  const stream = parseSelector(s.slice(1).trim());\n  if (stream.between) {\n    return {\n      between: b,\n      stream: stream\n    };\n  } else {\n    stream.between = b;\n  }\n\n  return stream;\n}\n\nfunction parseStream(s) {\n  const stream = {source: DEFAULT_SOURCE},\n        source = [];\n\n  let throttle = [0, 0],\n      markname = 0,\n      start = 0,\n      n = s.length,\n      i = 0, j,\n      filter;\n\n  // extract throttle from end\n  if (s[n-1] === RBRACE) {\n    i = s.lastIndexOf(LBRACE);\n    if (i >= 0) {\n      try {\n        throttle = parseThrottle(s.substring(i+1, n-1));\n      } catch (e) {\n        throw 'Invalid throttle specification: ' + s;\n      }\n      s = s.slice(0, i).trim();\n      n = s.length;\n    } else throw 'Unmatched right brace: ' + s;\n    i = 0;\n  }\n\n  if (!n) throw s;\n\n  // set name flag based on first char\n  if (s[0] === NAME) markname = ++i;\n\n  // extract first part of multi-part stream selector\n  j = find(s, i, COLON);\n  if (j < n) {\n    source.push(s.substring(start, j).trim());\n    start = i = ++j;\n  }\n\n  // extract remaining part of stream selector\n  i = find(s, i, LBRACK);\n  if (i === n) {\n    source.push(s.substring(start, n).trim());\n  } else {\n    source.push(s.substring(start, i).trim());\n    filter = [];\n    start = ++i;\n    if (start === n) throw 'Unmatched left bracket: ' + s;\n  }\n\n  // extract filters\n  while (i < n) {\n    i = find(s, i, RBRACK);\n    if (i === n) throw 'Unmatched left bracket: ' + s;\n    filter.push(s.substring(start, i).trim());\n    if (i < n-1 && s[++i] !== LBRACK) throw 'Expected left bracket: ' + s;\n    start = ++i;\n  }\n\n  // marshall event stream specification\n  if (!(n = source.length) || ILLEGAL.test(source[n-1])) {\n    throw 'Invalid event selector: ' + s;\n  }\n\n  if (n > 1) {\n    stream.type = source[1];\n    if (markname) {\n      stream.markname = source[0].slice(1);\n    } else if (isMarkType(source[0])) {\n      stream.marktype = source[0];\n    } else {\n      stream.source = source[0];\n    }\n  } else {\n    stream.type = source[0];\n  }\n  if (stream.type.slice(-1) === '!') {\n    stream.consume = true;\n    stream.type = stream.type.slice(0, -1);\n  }\n  if (filter != null) stream.filter = filter;\n  if (throttle[0]) stream.throttle = throttle[0];\n  if (throttle[1]) stream.debounce = throttle[1];\n\n  return stream;\n}\n\nfunction parseThrottle(s) {\n  const a = s.split(COMMA);\n  if (!s.length || a.length > 2) throw s;\n  return a.map(_ => {\n    const x = +_;\n    if (x !== x) throw s;\n    return x;\n  });\n}\n"],"names":["LBRACK","RBRACK","ILLEGAL","DEFAULT_MARKS","arc","area","group","image","line","path","rect","rule","shape","symbol","text","trail","DEFAULT_SOURCE","MARKS","find","s","i","endChar","pushChar","popChar","n","length","c","count","indexOf","parseMerge","output","start","push","substring","trim","parseSelector","b","slice","map","stream","between","parseBetween","source","j","filter","throttle","markname","lastIndexOf","a","split","_","x","parseThrottle","e","test","type","marktype","consume","debounce","parseStream","selector","marks"],"mappings":"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"}